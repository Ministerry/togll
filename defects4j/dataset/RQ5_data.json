[
    {
        "focal_method": "  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test39()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      String string0 = jsonReader0.nextString();\n      assertEquals(\"1\", string0);\n}",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */",
        "id": "1",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test39",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"1[Is\\\"A\\\"vL&\", string0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      String string0 = jsonReader0.nextString();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test39()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      String string0 = jsonReader0.nextString();\n      assertFalse(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "2",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test39",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      String string0 = jsonReader0.nextString();"
    },
    {
        "focal_method": "  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test39()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      String string0 = jsonReader0.nextString();\n      assertNotNull(string0);\n}",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */",
        "id": "3",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test39",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"1[Is\\\"A\\\"vL&\", string0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      String string0 = jsonReader0.nextString();"
    },
    {
        "focal_method": "  public String nextString() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test39()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      String string0 = jsonReader0.nextString();\n  }",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */",
        "id": "4",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test39",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"1[Is\\\"A\\\"vL&\", string0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      String string0 = jsonReader0.nextString();"
    },
    {
        "focal_method": "  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }",
        "test_prefix": "  public void test41()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"FALSE\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      boolean boolean0 = jsonReader0.nextBoolean();\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */",
        "id": "5",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test41",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"FALSE\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      boolean boolean0 = jsonReader0.nextBoolean();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test41()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"FALSE\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      boolean boolean0 = jsonReader0.nextBoolean();\n      assertFalse(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "6",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test41",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"FALSE\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      boolean boolean0 = jsonReader0.nextBoolean();"
    },
    {
        "focal_method": "  public boolean nextBoolean() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }",
        "test_prefix": "  public void test41()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"FALSE\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      boolean boolean0 = jsonReader0.nextBoolean();\n  }",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */",
        "id": "7",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test41",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"FALSE\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      boolean boolean0 = jsonReader0.nextBoolean();"
    },
    {
        "focal_method": "  public JsonToken peek() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    switch (p) {\n    case PEEKED_BEGIN_OBJECT:\n      return JsonToken.BEGIN_OBJECT;\n    case PEEKED_END_OBJECT:\n      return JsonToken.END_OBJECT;\n    case PEEKED_BEGIN_ARRAY:\n      return JsonToken.BEGIN_ARRAY;\n    case PEEKED_END_ARRAY:\n      return JsonToken.END_ARRAY;\n    case PEEKED_SINGLE_QUOTED_NAME:\n    case PEEKED_DOUBLE_QUOTED_NAME:\n    case PEEKED_UNQUOTED_NAME:\n      return JsonToken.NAME;\n    case PEEKED_TRUE:\n    case PEEKED_FALSE:\n      return JsonToken.BOOLEAN;\n    case PEEKED_NULL:\n      return JsonToken.NULL;\n    case PEEKED_SINGLE_QUOTED:\n    case PEEKED_DOUBLE_QUOTED:\n    case PEEKED_UNQUOTED:\n    case PEEKED_BUFFERED:\n      return JsonToken.STRING;\n    case PEEKED_LONG:\n    case PEEKED_NUMBER:\n      return JsonToken.NUMBER;\n    case PEEKED_EOF:\n      return JsonToken.END_DOCUMENT;\n    default:\n      throw new AssertionError();\n    }\n  }",
        "test_prefix": "  public void test42()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"NULL\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      JsonToken jsonToken0 = jsonReader0.peek();\n      assertEquals(JsonToken.NULL, jsonToken0);\n}",
        "docstring": "/**\n   * Returns the type of the next token without consuming it.\n   */",
        "id": "8",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test42",
        "except_pred": "0",
        "assert_pred": "assertNotNull(jsonToken0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"NULL\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      JsonToken jsonToken0 = jsonReader0.peek();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test42()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"NULL\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      JsonToken jsonToken0 = jsonReader0.peek();\n      assertFalse(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "9",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test42",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"NULL\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      JsonToken jsonToken0 = jsonReader0.peek();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test42()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"NULL\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      JsonToken jsonToken0 = jsonReader0.peek();\n      jsonReader0.nextNull();\n      assertFalse(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "10",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test42",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"NULL\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      JsonToken jsonToken0 = jsonReader0.peek();\n      jsonReader0.nextNull();"
    },
    {
        "focal_method": "  public void nextNull() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NULL) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n    } else {\n      throw new IllegalStateException(\"Expected null but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n  }",
        "test_prefix": "  public void test42()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"NULL\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      JsonToken jsonToken0 = jsonReader0.peek();\n      jsonReader0.nextNull();\n  }",
        "docstring": "/**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */",
        "id": "11",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test42",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, jsonToken0.getValueAsInt());",
        "prefix": "StringReader stringReader0 = new StringReader(\"NULL\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      JsonToken jsonToken0 = jsonReader0.peek();\n      jsonReader0.nextNull();"
    },
    {
        "focal_method": "  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test45()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      double double0 = jsonReader0.nextDouble();\n      assertEquals(1.0, double0, 0.01);\n}",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */",
        "id": "12",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test45",
        "except_pred": "0",
        "assert_pred": "assertEquals(2.0, double0, 0.01D);",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      double double0 = jsonReader0.nextDouble();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test45()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      double double0 = jsonReader0.nextDouble();\n      assertFalse(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "13",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test45",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      double double0 = jsonReader0.nextDouble();"
    },
    {
        "focal_method": "  public double nextDouble() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test45()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      double double0 = jsonReader0.nextDouble();\n  }",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */",
        "id": "14",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test45",
        "except_pred": "0",
        "assert_pred": "assertEquals(2.0, double0, 0.01D);",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      double double0 = jsonReader0.nextDouble();"
    },
    {
        "focal_method": "  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test49()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      long long0 = jsonReader0.nextLong();\n      assertEquals(1L, long0);\n}",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */",
        "id": "15",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test49",
        "except_pred": "0",
        "assert_pred": "assertEquals(2L, long0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      long long0 = jsonReader0.nextLong();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test49()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      long long0 = jsonReader0.nextLong();\n      assertFalse(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "16",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test49",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      long long0 = jsonReader0.nextLong();"
    },
    {
        "focal_method": "  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test49()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      long long0 = jsonReader0.nextLong();\n  }",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */",
        "id": "17",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test49",
        "except_pred": "0",
        "assert_pred": "assertEquals(2L, long0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      long long0 = jsonReader0.nextLong();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test68()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.skipValue();\n      assertFalse(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "18",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test68",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.skipValue();"
    },
    {
        "focal_method": "  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }",
        "test_prefix": "  public void test68()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.skipValue();\n  }",
        "docstring": "/**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */",
        "id": "19",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test68",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, stringReader0.read());",
        "prefix": "StringReader stringReader0 = new StringReader(\"1[Is\\\"A\\\"vL&\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.skipValue();"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.setHtmlSafe(true);\n      jsonWriter0.value(\"M8}<{;k$I]`5\");\n      assertEquals(\"\\\"M8}\\\\u003c{;k$I]`5\\\"\", stringWriter0.toString());\n}",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "20",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.setHtmlSafe(true);\n      jsonWriter0.value(\"M8}<{;k$I]`5\");"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.setHtmlSafe(true);\n      jsonWriter0.value(\"M8}<{;k$I]`5\");\n  }",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "21",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.setHtmlSafe(true);\n      jsonWriter0.value(\"M8}<{;k$I]`5\");"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test05()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value(1L);\n      assertEquals(\"1\", stringWriter0.toString());\n}",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "22",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test05",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{\\\"bytes\\\":[91,34,91,93,34,93],\\\"empty\\\":false,\\\"class\\\":\\\"class java.lang.String\\\"}\", stringWriter0.toString());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value(1L);"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test05()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value(1L);\n  }",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "23",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test05",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{\\\"bytes\\\":[91,34,91,93,34,93],\\\"empty\\\":false,\\\"class\\\":\\\"class java.lang.String\\\"}\", stringWriter0.toString());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value(1L);"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test17()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((String) null);\n      assertEquals(\"null\", stringWriter0.toString());\n}",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "24",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test17",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{\\\"bytes\\\":[91,34,91,93,34,93],\\\"empty\\\":false,\\\"class\\\":\\\"class java.lang.String\\\"}\", stringWriter0.toString());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((String) null);"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test17()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((String) null);\n  }",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "25",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test17",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{\\\"bytes\\\":[91,34,91,93,34,93],\\\"empty\\\":false,\\\"class\\\":\\\"class java.lang.String\\\"}\", stringWriter0.toString());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((String) null);"
    },
    {
        "focal_method": "  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.jsonValue(\"java.lang#Float@0000000003\");\n      assertTrue(jsonWriter1.getSerializeNulls());\n}",
        "docstring": "/**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */",
        "id": "26",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonWriter0.getSerializeNulls());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.jsonValue(\"java.lang#Float@0000000003\");"
    },
    {
        "focal_method": "  public JsonWriter jsonValue(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    out.append(value);\n    return this;\n  }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.jsonValue(\"java.lang#Float@0000000003\");\n  }",
        "docstring": "/**\n   * Writes {@code value} directly to the writer without quoting or\n   * escaping.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "27",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertNotNull(jsonWriter1);",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.jsonValue(\"java.lang#Float@0000000003\");"
    },
    {
        "focal_method": "  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }",
        "test_prefix": "  public void test20()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.value(true);\n      jsonWriter1.close();\n      jsonWriter1.close();\n      assertEquals(\"true\", stringWriter0.toString());\n}",
        "docstring": "/**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */",
        "id": "28",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test20",
        "except_pred": "0",
        "assert_pred": "assertSame(jsonWriter0, jsonWriter1);",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.value(true);\n      jsonWriter1.close();\n      jsonWriter1.close();"
    },
    {
        "focal_method": "  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }",
        "test_prefix": "  public void test20()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.value(true);\n      jsonWriter1.close();\n      jsonWriter1.close();\n      assertTrue(jsonWriter0.getSerializeNulls());\n}",
        "docstring": "/**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */",
        "id": "29",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test20",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonWriter0.getSerializeNulls());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.value(true);\n      jsonWriter1.close();\n      jsonWriter1.close();"
    },
    {
        "focal_method": "  private JsonWriter close(int empty, int nonempty, String closeBracket)\n      throws IOException {\n    int context = peek();\n    if (context != nonempty && context != empty) {\n      throw new IllegalStateException(\"Nesting problem.\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    stackSize--;\n    if (context == nonempty) {\n      newline();\n    }\n    out.write(closeBracket);\n    return this;\n  }",
        "test_prefix": "  public void test20()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.value(true);\n      jsonWriter1.close();\n      jsonWriter1.close();\n  }",
        "docstring": "/**\n   * Closes the current scope by appending any necessary whitespace and the\n   * given bracket.\n   */",
        "id": "30",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test20",
        "except_pred": "0",
        "assert_pred": "assertSame(jsonWriter0, jsonWriter1);",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.value(true);\n      jsonWriter1.close();\n      jsonWriter1.close();"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test31()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.nullValue();\n      jsonWriter1.setLenient(true);\n      jsonWriter0.value(\"n!:le\");\n      assertEquals(\"null\\\"n!:le\\\"\", stringWriter0.toString());\n}",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "31",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test31",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{\\\"bytes\\\":[91,34,91,93,34,93],\\\"empty\\\":false,\\\"class\\\":\\\"class java.lang.String\\\"}\", stringWriter0.toString());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.nullValue();\n      jsonWriter1.setLenient(true);\n      jsonWriter0.value(\"n!:le\");"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test31()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.nullValue();\n      jsonWriter1.setLenient(true);\n      jsonWriter0.value(\"n!:le\");\n  }",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "32",
        "project": "Gson",
        "bug_num": "4",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test31",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{\\\"bytes\\\":[91,34,91,93,34,93],\\\"empty\\\":false,\\\"class\\\":\\\"class java.lang.String\\\"}\", stringWriter0.toString());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      JsonWriter jsonWriter1 = jsonWriter0.nullValue();\n      jsonWriter1.setLenient(true);\n      jsonWriter0.value(\"n!:le\");"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test59()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      long long0 = jsonReader0.nextLong();\n      assertTrue(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "33",
        "project": "Gson",
        "bug_num": "7",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test59",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      long long0 = jsonReader0.nextLong();"
    },
    {
        "focal_method": "  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test59()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      long long0 = jsonReader0.nextLong();\n      assertEquals(464L, long0);\n}",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */",
        "id": "34",
        "project": "Gson",
        "bug_num": "7",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test59",
        "except_pred": "0",
        "assert_pred": "assertEquals(0L, long0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      long long0 = jsonReader0.nextLong();"
    },
    {
        "focal_method": "  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test59()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      long long0 = jsonReader0.nextLong();\n  }",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */",
        "id": "35",
        "project": "Gson",
        "bug_num": "7",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test59",
        "except_pred": "0",
        "assert_pred": "assertEquals(0L, long0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      long long0 = jsonReader0.nextLong();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test76()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      int int0 = jsonReader0.nextInt();\n      assertTrue(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "36",
        "project": "Gson",
        "bug_num": "7",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test76",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      int int0 = jsonReader0.nextInt();"
    },
    {
        "focal_method": "  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
        "test_prefix": "  public void test76()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      int int0 = jsonReader0.nextInt();\n      assertEquals(464, int0);\n}",
        "docstring": "/**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */",
        "id": "37",
        "project": "Gson",
        "bug_num": "7",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test76",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, int0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      int int0 = jsonReader0.nextInt();"
    },
    {
        "focal_method": "  public final boolean isLenient() {\n    return lenient;\n  }",
        "test_prefix": "  public void test76()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      int int0 = jsonReader0.nextInt();\n      jsonReader0.skipValue();\n      assertTrue(jsonReader0.isLenient());\n}",
        "docstring": "/**\n   * Returns true if this parser is liberal in what it accepts.\n   */",
        "id": "38",
        "project": "Gson",
        "bug_num": "7",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test76",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, jsonReader0.isLenient());",
        "prefix": "StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      int int0 = jsonReader0.nextInt();\n      jsonReader0.skipValue();"
    },
    {
        "focal_method": "  public void skipValue() throws IOException {\n    int count = 0;\n    do {\n      int p = peeked;\n      if (p == PEEKED_NONE) {\n        p = doPeek();\n      }\n\n      if (p == PEEKED_BEGIN_ARRAY) {\n        push(JsonScope.EMPTY_ARRAY);\n        count++;\n      } else if (p == PEEKED_BEGIN_OBJECT) {\n        push(JsonScope.EMPTY_OBJECT);\n        count++;\n      } else if (p == PEEKED_END_ARRAY) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_END_OBJECT) {\n        stackSize--;\n        count--;\n      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n        skipUnquotedValue();\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n        skipQuotedValue('\\'');\n      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n        skipQuotedValue('\"');\n      } else if (p == PEEKED_NUMBER) {\n        pos += peekedNumberLength;\n      }\n      peeked = PEEKED_NONE;\n    } while (count != 0);\n\n    pathIndices[stackSize - 1]++;\n    pathNames[stackSize - 1] = \"null\";\n  }",
        "test_prefix": "  public void test76()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      int int0 = jsonReader0.nextInt();\n      jsonReader0.skipValue();\n  }",
        "docstring": "/**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */",
        "id": "39",
        "project": "Gson",
        "bug_num": "7",
        "test_name": "com.google.gson.stream.JsonReader_ESTest::test76",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, int0);",
        "prefix": "StringReader stringReader0 = new StringReader(\"464D\");\n      JsonReader jsonReader0 = new JsonReader(stringReader0);\n      jsonReader0.setLenient(true);\n      int int0 = jsonReader0.nextInt();\n      jsonReader0.skipValue();"
    },
    {
        "focal_method": "  @Override public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      JsonTreeWriter jsonTreeWriter0 = new JsonTreeWriter();\n      JsonWriter jsonWriter0 = jsonTreeWriter0.value((Boolean) null);\n      assertSame(jsonTreeWriter0, jsonWriter0);\n}",
        "docstring": "",
        "id": "40",
        "project": "Gson",
        "bug_num": "9",
        "test_name": "com.google.gson.internal.bind.JsonTreeWriter_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertNotNull(jsonWriter0);",
        "prefix": "JsonTreeWriter jsonTreeWriter0 = new JsonTreeWriter();\n      JsonWriter jsonWriter0 = jsonTreeWriter0.value((Boolean) null);"
    },
    {
        "focal_method": "  @Override public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    put(new JsonPrimitive(value));\n    return this;\n  }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      JsonTreeWriter jsonTreeWriter0 = new JsonTreeWriter();\n      JsonWriter jsonWriter0 = jsonTreeWriter0.value((Boolean) null);\n  }",
        "docstring": "",
        "id": "41",
        "project": "Gson",
        "bug_num": "9",
        "test_name": "com.google.gson.internal.bind.JsonTreeWriter_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertNotNull(jsonWriter0);",
        "prefix": "JsonTreeWriter jsonTreeWriter0 = new JsonTreeWriter();\n      JsonWriter jsonWriter0 = jsonTreeWriter0.value((Boolean) null);"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((Boolean) null);\n      assertEquals(\"null\", stringWriter0.toString());\n}",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "42",
        "project": "Gson",
        "bug_num": "9",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{\\\"bytes\\\":[91,34,91,93,34,93],\\\"empty\\\":false,\\\"class\\\":\\\"class java.lang.String\\\"}\", stringWriter0.toString());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((Boolean) null);"
    },
    {
        "focal_method": "  public final boolean getSerializeNulls() {\n    return serializeNulls;\n  }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((Boolean) null);\n      assertTrue(jsonWriter0.getSerializeNulls());\n}",
        "docstring": "/**\n   * Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true.\n   */",
        "id": "43",
        "project": "Gson",
        "bug_num": "9",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, jsonWriter0.getSerializeNulls());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((Boolean) null);"
    },
    {
        "focal_method": "  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    string(value);\n    return this;\n  }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((Boolean) null);\n  }",
        "docstring": "/**\n   * Encodes {@code value}.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   */",
        "id": "44",
        "project": "Gson",
        "bug_num": "9",
        "test_name": "com.google.gson.stream.JsonWriter_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{\\\"bytes\\\":[91,34,91,93,34,93],\\\"empty\\\":false,\\\"class\\\":\\\"class java.lang.String\\\"}\", stringWriter0.toString());",
        "prefix": "StringWriter stringWriter0 = new StringWriter();\n      JsonWriter jsonWriter0 = new JsonWriter(stringWriter0);\n      jsonWriter0.value((Boolean) null);"
    },
    {
        "focal_method": "  DefaultDateTypeAdapter(Class<? extends Date> dateType) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n  }",
        "test_prefix": "  public void test7()  throws Throwable  {\n      Class<Timestamp> class0 = Timestamp.class;\n      DefaultDateTypeAdapter defaultDateTypeAdapter0 = new DefaultDateTypeAdapter(class0, \"]: \");\n      JsonNull jsonNull0 = JsonNull.INSTANCE;\n      java.util.Date date0 = defaultDateTypeAdapter0.fromJsonTree(jsonNull0);\n      assertNull(date0);\n}",
        "docstring": "",
        "id": "45",
        "project": "Gson",
        "bug_num": "17",
        "test_name": "com.google.gson.DefaultDateTypeAdapter_ESTest::test7",
        "except_pred": "0",
        "assert_pred": "assertNotNull(date0);",
        "prefix": "Class<Timestamp> class0 = Timestamp.class;\n      DefaultDateTypeAdapter defaultDateTypeAdapter0 = new DefaultDateTypeAdapter(class0, \"]: \");\n      JsonNull jsonNull0 = JsonNull.INSTANCE;\n      java.util.Date date0 = defaultDateTypeAdapter0.fromJsonTree(jsonNull0);"
    },
    {
        "focal_method": "  DefaultDateTypeAdapter(Class<? extends Date> dateType) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\n        DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n  }",
        "test_prefix": "  public void test7()  throws Throwable  {\n      Class<Timestamp> class0 = Timestamp.class;\n      DefaultDateTypeAdapter defaultDateTypeAdapter0 = new DefaultDateTypeAdapter(class0, \"]: \");\n      JsonNull jsonNull0 = JsonNull.INSTANCE;\n      java.util.Date date0 = defaultDateTypeAdapter0.fromJsonTree(jsonNull0);\n  }",
        "docstring": "",
        "id": "46",
        "project": "Gson",
        "bug_num": "17",
        "test_name": "com.google.gson.DefaultDateTypeAdapter_ESTest::test7",
        "except_pred": "0",
        "assert_pred": "assertNotNull(date0);",
        "prefix": "Class<Timestamp> class0 = Timestamp.class;\n      DefaultDateTypeAdapter defaultDateTypeAdapter0 = new DefaultDateTypeAdapter(class0, \"]: \");\n      JsonNull jsonNull0 = JsonNull.INSTANCE;\n      java.util.Date date0 = defaultDateTypeAdapter0.fromJsonTree(jsonNull0);"
    },
    {
        "focal_method": "    public boolean testNode(NodeTest test) {\n        return testNode(node, test);\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl();\n      Locale locale0 = Locale.FRENCH;\n      HTMLTableElementImpl hTMLTableElementImpl0 = new HTMLTableElementImpl(hTMLDocumentImpl0, \"Unknown namespace prefix: \");\n      DOMNodePointer dOMNodePointer0 = new DOMNodePointer(hTMLTableElementImpl0, locale0);\n      QName qName0 = dOMNodePointer0.getName();\n      NodeNameTest nodeNameTest0 = new NodeNameTest(qName0, \"http://www.w3.org/XML/1998/namespace\");\n      boolean boolean0 = dOMNodePointer0.testNode((NodeTest) nodeNameTest0);\n      assertTrue(boolean0);\n}",
        "docstring": "",
        "id": "47",
        "project": "JxPath",
        "bug_num": "12",
        "test_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer_ESTest::test24",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl();\n      Locale locale0 = Locale.FRENCH;\n      HTMLTableElementImpl hTMLTableElementImpl0 = new HTMLTableElementImpl(hTMLDocumentImpl0, \"Unknown namespace prefix: \");\n      DOMNodePointer dOMNodePointer0 = new DOMNodePointer(hTMLTableElementImpl0, locale0);\n      QName qName0 = dOMNodePointer0.getName();\n      NodeNameTest nodeNameTest0 = new NodeNameTest(qName0, \"http://www.w3.org/XML/1998/namespace\");\n      boolean boolean0 = dOMNodePointer0.testNode((NodeTest) nodeNameTest0);"
    },
    {
        "focal_method": "    protected Object functionRound(EvalContext context) {\n        assertArgCount(1);\n        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n        return new Double(Math.round(v));\n    }",
        "test_prefix": "  public void test79()  throws Throwable  {\n      Constant constant0 = new Constant(\"concat\");\n      Expression[] expressionArray0 = new Expression[1];\n      expressionArray0[0] = (Expression) constant0;\n      CoreFunction coreFunction0 = new CoreFunction(7, expressionArray0);\n      Object object0 = coreFunction0.functionRound((EvalContext) null);\n      assertEquals(Double.NaN, object0);\n}",
        "docstring": "",
        "id": "48",
        "project": "JxPath",
        "bug_num": "14",
        "test_name": "org.apache.commons.jxpath.ri.compiler.CoreFunction_ESTest::test79",
        "except_pred": "0",
        "assert_pred": "assertNotNull(object0);",
        "prefix": "Constant constant0 = new Constant(\"concat\");\n      Expression[] expressionArray0 = new Expression[1];\n      expressionArray0[0] = (Expression) constant0;\n      CoreFunction coreFunction0 = new CoreFunction(7, expressionArray0);\n      Object object0 = coreFunction0.functionRound((EvalContext) null);"
    },
    {
        "focal_method": "    public int compareTo(Object object) {\n        // Let it throw a ClassCastException\n        NodePointer pointer = (NodePointer) object;\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\n        // Task 1: find the common parent\n        int depth1 = 0;\n        NodePointer p1 = this;\n        while (p1 != null) {\n            depth1++;\n            p1 = p1.parent;\n        }\n        int depth2 = 0;\n        NodePointer p2 = pointer;\n        while (p2 != null) {\n            depth2++;\n            p2 = p2.parent;\n        }\n        return compareNodePointers(this, depth1, pointer, depth2);\n    }",
        "test_prefix": "  public void test48()  throws Throwable  {\n      QName qName0 = new QName(\"\");\n      VariablePointer variablePointer0 = new VariablePointer(qName0);\n      NodePointer nodePointer0 = NodePointer.newChildNodePointer(variablePointer0, qName0, qName0);\n      BasicVariables basicVariables0 = new BasicVariables();\n      VariablePointer variablePointer1 = new VariablePointer(basicVariables0, qName0);\n      int int0 = nodePointer0.compareTo(variablePointer1);\n      assertEquals(1, int0);\n}",
        "docstring": "",
        "id": "49",
        "project": "JxPath",
        "bug_num": "5",
        "test_name": "org.apache.commons.jxpath.ri.model.NodePointer_ESTest::test48",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, int0);",
        "prefix": "QName qName0 = new QName(\"\");\n      VariablePointer variablePointer0 = new VariablePointer(qName0);\n      NodePointer nodePointer0 = NodePointer.newChildNodePointer(variablePointer0, qName0, qName0);\n      BasicVariables basicVariables0 = new BasicVariables();\n      VariablePointer variablePointer1 = new VariablePointer(basicVariables0, qName0);\n      int int0 = nodePointer0.compareTo(variablePointer1);"
    },
    {
        "focal_method": "    public int getIndex() {\n        return index;\n    }",
        "test_prefix": "  public void test48()  throws Throwable  {\n      QName qName0 = new QName(\"\");\n      VariablePointer variablePointer0 = new VariablePointer(qName0);\n      NodePointer nodePointer0 = NodePointer.newChildNodePointer(variablePointer0, qName0, qName0);\n      BasicVariables basicVariables0 = new BasicVariables();\n      VariablePointer variablePointer1 = new VariablePointer(basicVariables0, qName0);\n      int int0 = nodePointer0.compareTo(variablePointer1);\n      assertEquals(Integer.MIN_VALUE, variablePointer1.getIndex());\n}",
        "docstring": "/**\n     * If the pointer represents a collection, the index identifies\n     * an element of that collection.  The default value of <code>index</code>\n     * is <code>WHOLE_COLLECTION</code>, which just means that the pointer\n     * is not indexed at all.\n     * Note: the index on NodePointer starts with 0, not 1.\n     */",
        "id": "50",
        "project": "JxPath",
        "bug_num": "5",
        "test_name": "org.apache.commons.jxpath.ri.model.NodePointer_ESTest::test48",
        "except_pred": "0",
        "assert_pred": "assertEquals(-1, nodePointer0.getIndex());",
        "prefix": "QName qName0 = new QName(\"\");\n      VariablePointer variablePointer0 = new VariablePointer(qName0);\n      NodePointer nodePointer0 = NodePointer.newChildNodePointer(variablePointer0, qName0, qName0);\n      BasicVariables basicVariables0 = new BasicVariables();\n      VariablePointer variablePointer1 = new VariablePointer(basicVariables0, qName0);\n      int int0 = nodePointer0.compareTo(variablePointer1);"
    },
    {
        "focal_method": "    public int compareTo(Object object) {\n        // Let it throw a ClassCastException\n        NodePointer pointer = (NodePointer) object;\n        if (parent == pointer.parent) {\n            return parent == null ? 0 : parent.compareChildNodePointers(this, pointer);\n        }\n\n        // Task 1: find the common parent\n        int depth1 = 0;\n        NodePointer p1 = this;\n        while (p1 != null) {\n            depth1++;\n            p1 = p1.parent;\n        }\n        int depth2 = 0;\n        NodePointer p2 = pointer;\n        while (p2 != null) {\n            depth2++;\n            p2 = p2.parent;\n        }\n        return compareNodePointers(this, depth1, pointer, depth2);\n    }",
        "test_prefix": "  public void test48()  throws Throwable  {\n      QName qName0 = new QName(\"\");\n      VariablePointer variablePointer0 = new VariablePointer(qName0);\n      NodePointer nodePointer0 = NodePointer.newChildNodePointer(variablePointer0, qName0, qName0);\n      BasicVariables basicVariables0 = new BasicVariables();\n      VariablePointer variablePointer1 = new VariablePointer(basicVariables0, qName0);\n      int int0 = nodePointer0.compareTo(variablePointer1);\n  }",
        "docstring": "",
        "id": "51",
        "project": "JxPath",
        "bug_num": "5",
        "test_name": "org.apache.commons.jxpath.ri.model.NodePointer_ESTest::test48",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, int0);",
        "prefix": "QName qName0 = new QName(\"\");\n      VariablePointer variablePointer0 = new VariablePointer(qName0);\n      NodePointer nodePointer0 = NodePointer.newChildNodePointer(variablePointer0, qName0, qName0);\n      BasicVariables basicVariables0 = new BasicVariables();\n      VariablePointer variablePointer1 = new VariablePointer(basicVariables0, qName0);\n      int int0 = nodePointer0.compareTo(variablePointer1);"
    },
    {
        "focal_method": "    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1]\n                .computeValue(context)) ? Boolean.TRUE : Boolean.FALSE;\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      Constant constant0 = new Constant(\"9|\");\n      CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual0 = new CoreOperationGreaterThanOrEqual(constant0, constant0);\n      CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual1 = new CoreOperationGreaterThanOrEqual(coreOperationGreaterThanOrEqual0, constant0);\n      Object object0 = coreOperationGreaterThanOrEqual1.computeValue((EvalContext) null);\n      assertEquals(false, object0);\n}",
        "docstring": "",
        "id": "52",
        "project": "JxPath",
        "bug_num": "8",
        "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertNotNull(object0);",
        "prefix": "Constant constant0 = new Constant(\"9|\");\n      CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual0 = new CoreOperationGreaterThanOrEqual(constant0, constant0);\n      CoreOperationGreaterThanOrEqual coreOperationGreaterThanOrEqual1 = new CoreOperationGreaterThanOrEqual(coreOperationGreaterThanOrEqual0, constant0);\n      Object object0 = coreOperationGreaterThanOrEqual1.computeValue((EvalContext) null);"
    },
    {
        "focal_method": "    public boolean testNode(NodeTest test) {\n        return testNode(this, node, test);\n    }",
        "test_prefix": "  public void test30()  throws Throwable  {\n      QName qName0 = new QName(\"[QT~sGq>_#hT|#8m\", \"[QT~sGq>_#hT|#8m\");\n      VariablePointer variablePointer0 = new VariablePointer(qName0);\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1);\n      boolean boolean0 = JDOMNodePointer.testNode((NodePointer) variablePointer0, (Object) null, (NodeTest) nodeTypeTest0);\n      assertTrue(boolean0);\n}",
        "docstring": "",
        "id": "53",
        "project": "JxPath",
        "bug_num": "16",
        "test_name": "org.apache.commons.jxpath.ri.model.jdom.JDOMNodePointer_ESTest::test30",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "QName qName0 = new QName(\"[QT~sGq>_#hT|#8m\", \"[QT~sGq>_#hT|#8m\");\n      VariablePointer variablePointer0 = new VariablePointer(qName0);\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1);\n      boolean boolean0 = JDOMNodePointer.testNode((NodePointer) variablePointer0, (Object) null, (NodeTest) nodeTypeTest0);"
    },
    {
        "focal_method": "",
        "test_prefix": "  public void test01()  throws Throwable  {\n      QName qName0 = new QName(\"\", \"\");\n      VariableReference variableReference0 = new VariableReference(qName0);\n      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);\n      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);\n      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);\n      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);\n      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);\n      Boolean boolean0 = (Boolean)coreOperationNotEqual0.computeValue(childContext0);\n      assertTrue(boolean0);\n}",
        "docstring": "",
        "id": "54",
        "project": "JxPath",
        "bug_num": "6",
        "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationCompare_ESTest::test01",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0.booleanValue());",
        "prefix": "QName qName0 = new QName(\"\", \"\");\n      VariableReference variableReference0 = new VariableReference(qName0);\n      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);\n      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);\n      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);\n      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);\n      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);\n      Boolean boolean0 = (Boolean)coreOperationNotEqual0.computeValue(childContext0);"
    },
    {
        "focal_method": "",
        "test_prefix": "  public void test01()  throws Throwable  {\n      QName qName0 = new QName(\"\", \"\");\n      VariableReference variableReference0 = new VariableReference(qName0);\n      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);\n      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);\n      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);\n      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);\n      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);\n      Boolean boolean0 = (Boolean)coreOperationNotEqual0.computeValue(childContext0);\n  }",
        "docstring": "",
        "id": "55",
        "project": "JxPath",
        "bug_num": "6",
        "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationCompare_ESTest::test01",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0.booleanValue());",
        "prefix": "QName qName0 = new QName(\"\", \"\");\n      VariableReference variableReference0 = new VariableReference(qName0);\n      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);\n      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);\n      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);\n      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);\n      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);\n      Boolean boolean0 = (Boolean)coreOperationNotEqual0.computeValue(childContext0);"
    },
    {
        "focal_method": "    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right) \n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n//        System.err.println(\"COMPARING: \" +\n//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n//            (r == null ? \"null\" : r.getClass().getName()));\n\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        if (l instanceof Collection) {\n            l = ((Collection) l).iterator();\n        }\n\n        if (r instanceof Collection) {\n            r = ((Collection) r).iterator();\n        }\n\n        if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n            return contains((Iterator) l, r);\n        }\n        if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n            return contains((Iterator) r, l);\n        }\n        if (l instanceof Iterator && r instanceof Iterator) {\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        return equal(l, r);\n    }",
        "test_prefix": "  public void test02()  throws Throwable  {\n      QName qName0 = new QName(\"\", \"\");\n      VariableReference variableReference0 = new VariableReference(qName0);\n      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);\n      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);\n      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);\n      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);\n      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);\n      boolean boolean0 = coreOperationNotEqual0.equal(childContext0, variableReference0, nameAttributeTest0);\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n     * Compares two values\n     */",
        "id": "56",
        "project": "JxPath",
        "bug_num": "6",
        "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationCompare_ESTest::test02",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "QName qName0 = new QName(\"\", \"\");\n      VariableReference variableReference0 = new VariableReference(qName0);\n      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);\n      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);\n      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);\n      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);\n      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);\n      boolean boolean0 = coreOperationNotEqual0.equal(childContext0, variableReference0, nameAttributeTest0);"
    },
    {
        "focal_method": "    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right) \n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n//        System.err.println(\"COMPARING: \" +\n//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n//            (r == null ? \"null\" : r.getClass().getName()));\n\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        if (l instanceof Collection) {\n            l = ((Collection) l).iterator();\n        }\n\n        if (r instanceof Collection) {\n            r = ((Collection) r).iterator();\n        }\n\n        if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n            return contains((Iterator) l, r);\n        }\n        if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n            return contains((Iterator) r, l);\n        }\n        if (l instanceof Iterator && r instanceof Iterator) {\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        return equal(l, r);\n    }",
        "test_prefix": "  public void test02()  throws Throwable  {\n      QName qName0 = new QName(\"\", \"\");\n      VariableReference variableReference0 = new VariableReference(qName0);\n      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);\n      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);\n      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);\n      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);\n      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);\n      boolean boolean0 = coreOperationNotEqual0.equal(childContext0, variableReference0, nameAttributeTest0);\n  }",
        "docstring": "/**\n     * Compares two values\n     */",
        "id": "57",
        "project": "JxPath",
        "bug_num": "6",
        "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationCompare_ESTest::test02",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "QName qName0 = new QName(\"\", \"\");\n      VariableReference variableReference0 = new VariableReference(qName0);\n      NameAttributeTest nameAttributeTest0 = new NameAttributeTest(variableReference0, variableReference0);\n      CoreOperationNotEqual coreOperationNotEqual0 = new CoreOperationNotEqual(nameAttributeTest0, variableReference0);\n      JXPathContextReferenceImpl jXPathContextReferenceImpl0 = (JXPathContextReferenceImpl)JXPathContext.newContext((Object) coreOperationNotEqual0);\n      InitialContext initialContext0 = (InitialContext)jXPathContextReferenceImpl0.getAbsoluteRootContext();\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(Integer.MIN_VALUE);\n      ChildContext childContext0 = new ChildContext(initialContext0, nodeTypeTest0, true, true);\n      boolean boolean0 = coreOperationNotEqual0.equal(childContext0, variableReference0, nameAttributeTest0);"
    },
    {
        "focal_method": "    public String asPath() {\n        if (id != null) {\n            return \"id('\" + escape(id) + \"')\";\n        }\n\n        StringBuffer buffer = new StringBuffer();\n        if (parent != null) {\n            buffer.append(parent.asPath());\n        }\n        switch (node.getNodeType()) {\n            case Node.ELEMENT_NODE :\n                // If the parent pointer is not a DOMNodePointer, it is\n                // the parent's responsibility to produce the node test part\n                // of the path\n                if (parent instanceof DOMNodePointer) {\n                    if (buffer.length() == 0\n                            || buffer.charAt(buffer.length() - 1) != '/') {\n                        buffer.append('/');\n                    }\n                    String ln = DOMNodePointer.getLocalName(node);\n                    String nsURI = getNamespaceURI();\n                    if (nsURI == null) {\n                        buffer.append(ln);\n                        buffer.append('[');\n                        buffer.append(getRelativePositionByQName()).append(']');\n                    }\n                    else {\n                        String prefix = getNamespaceResolver().getPrefix(nsURI);\n                        if (prefix != null) {\n                            buffer.append(prefix);\n                            buffer.append(':');\n                            buffer.append(ln);\n                            buffer.append('[');\n                            buffer.append(getRelativePositionByQName());\n                            buffer.append(']');\n                        }\n                        else {\n                            buffer.append(\"node()\");\n                            buffer.append('[');\n                            buffer.append(getRelativePositionOfElement());\n                            buffer.append(']');\n                        }\n                    }\n                }\n            break;\n            case Node.TEXT_NODE :\n            case Node.CDATA_SECTION_NODE :\n                buffer.append(\"/text()\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfTextNode()).append(']');\n                break;\n            case Node.PROCESSING_INSTRUCTION_NODE :\n                buffer.append(\"/processing-instruction(\\'\");\n                buffer.append(((ProcessingInstruction) node).getTarget()).append(\"')\");\n                buffer.append('[');\n                buffer.append(getRelativePositionOfPI()).append(']');\n                break;\n            case Node.DOCUMENT_NODE :\n                // That'll be empty\n                break;\n            default:\n                break;\n        }\n        return buffer.toString();\n    }",
        "test_prefix": "  public void test65()  throws Throwable  {\n      HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl();\n      DOMNodePointer dOMNodePointer0 = new DOMNodePointer((NodePointer) null, hTMLDocumentImpl0);\n      PSVIDocumentImpl pSVIDocumentImpl0 = new PSVIDocumentImpl();\n      Element element0 = pSVIDocumentImpl0.createElementNS(\"\", \"Factory could not create a child node for path: \", \"xmlns\");\n      DOMNodePointer dOMNodePointer1 = new DOMNodePointer(dOMNodePointer0, element0);\n      String string0 = dOMNodePointer1.asPath();\n      assertEquals(\"/xmlns[1]\", string0);\n}",
        "docstring": "",
        "id": "58",
        "project": "JxPath",
        "bug_num": "22",
        "test_name": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer_ESTest::test65",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"/xmlns:Factory could not create a child node for path: \", string0);",
        "prefix": "HTMLDocumentImpl hTMLDocumentImpl0 = new HTMLDocumentImpl();\n      DOMNodePointer dOMNodePointer0 = new DOMNodePointer((NodePointer) null, hTMLDocumentImpl0);\n      PSVIDocumentImpl pSVIDocumentImpl0 = new PSVIDocumentImpl();\n      Element element0 = pSVIDocumentImpl0.createElementNS(\"\", \"Factory could not create a child node for path: \", \"xmlns\");\n      DOMNodePointer dOMNodePointer1 = new DOMNodePointer(dOMNodePointer0, element0);\n      String string0 = dOMNodePointer1.asPath();"
    },
    {
        "focal_method": "    public boolean setPosition(int position) {\n        if (position < getCurrentPosition()) {\n            reset();\n        }\n\n        while (getCurrentPosition() < position) {\n            if (!nextNode()) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      BasicNodeSet basicNodeSet0 = new BasicNodeSet();\n      NodeSetContext nodeSetContext0 = new NodeSetContext((EvalContext) null, basicNodeSet0);\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1);\n      ChildContext childContext0 = new ChildContext(nodeSetContext0, nodeTypeTest0, true, true);\n      AttributeContext attributeContext0 = new AttributeContext(childContext0, nodeTypeTest0);\n      // Undeclared exception!\n      try { \n        attributeContext0.setPosition(1);\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n         //\n         // no message in exception (getMessage() returned null)\n         //\n         verifyException(\"org.apache.commons.jxpath.ri.axes.AttributeContext\", e);\n      }\n  }",
        "docstring": "",
        "id": "59",
        "project": "JxPath",
        "bug_num": "18",
        "test_name": "org.apache.commons.jxpath.ri.axes.AttributeContext_ESTest::test4",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BasicNodeSet basicNodeSet0 = new BasicNodeSet();\n      NodeSetContext nodeSetContext0 = new NodeSetContext((EvalContext) null, basicNodeSet0);\n      NodeTypeTest nodeTypeTest0 = new NodeTypeTest(1);\n      ChildContext childContext0 = new ChildContext(nodeSetContext0, nodeTypeTest0, true, true);\n      AttributeContext attributeContext0 = new AttributeContext(childContext0, nodeTypeTest0);\n      // Undeclared exception!\n       \n        attributeContext0.setPosition(1);"
    },
    {
        "focal_method": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      BrentOptimizer brentOptimizer0 = new BrentOptimizer();\n      double[] doubleArray0 = new double[8];\n      doubleArray0[2] = (-873.217716);\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      GoalType goalType0 = GoalType.MAXIMIZE;\n      double double0 = brentOptimizer0.optimize((UnivariateRealFunction) polynomialFunction0, goalType0, (-873.217716), 0.0, (-1.0));\n      assertEquals(56, brentOptimizer0.getEvaluations());\n}",
        "docstring": "",
        "id": "60",
        "project": "Math",
        "bug_num": "66",
        "test_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(0.0, double0, 0.01D);",
        "prefix": "BrentOptimizer brentOptimizer0 = new BrentOptimizer();\n      double[] doubleArray0 = new double[8];\n      doubleArray0[2] = (-873.217716);\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      GoalType goalType0 = GoalType.MAXIMIZE;\n      double double0 = brentOptimizer0.optimize((UnivariateRealFunction) polynomialFunction0, goalType0, (-873.217716), 0.0, (-1.0));"
    },
    {
        "focal_method": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      BrentOptimizer brentOptimizer0 = new BrentOptimizer();\n      double[] doubleArray0 = new double[8];\n      doubleArray0[5] = Double.NaN;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      GoalType goalType0 = GoalType.MINIMIZE;\n      double double0 = brentOptimizer0.optimize((UnivariateRealFunction) polynomialFunction0, goalType0, 0.0, (-874.0), (-4351.645960419921));\n      assertEquals(21, brentOptimizer0.getIterationCount());\n}",
        "docstring": "",
        "id": "61",
        "project": "Math",
        "bug_num": "66",
        "test_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertEquals(0.0, double0, 0.01D);",
        "prefix": "BrentOptimizer brentOptimizer0 = new BrentOptimizer();\n      double[] doubleArray0 = new double[8];\n      doubleArray0[5] = Double.NaN;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      GoalType goalType0 = GoalType.MINIMIZE;\n      double double0 = brentOptimizer0.optimize((UnivariateRealFunction) polynomialFunction0, goalType0, 0.0, (-874.0), (-4351.645960419921));"
    },
    {
        "focal_method": "    public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                   final int populationLimit,\n                                   final double elitismRate) {\n        super(chromosomes, populationLimit);\n        this.elitismRate = elitismRate;\n    }",
        "test_prefix": "  public void test0()  throws Throwable  {\n      LinkedList<Chromosome> linkedList0 = new LinkedList<Chromosome>();\n      ElitisticListPopulation elitisticListPopulation0 = null;\n      try {\n        elitisticListPopulation0 = new ElitisticListPopulation(linkedList0, 2144375856, 2144375856);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // elitism rate (2,144,375,856)\n         //\n         verifyException(\"org.apache.commons.math3.genetics.ElitisticListPopulation\", e);\n      }\n  }",
        "docstring": "/**\n     * Creates a new ElitisticListPopulation instance.\n     *\n     * @param chromosomes list of chromosomes in the population\n     * @param populationLimit maximal size of the population\n     * @param elitismRate how many best chromosomes will be directly transferred to the\n     *                    next generation [in %]\n     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n     */",
        "id": "62",
        "project": "Math",
        "bug_num": "35",
        "test_name": "org.apache.commons.math3.genetics.ElitisticListPopulation_ESTest::test0",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "LinkedList<Chromosome> linkedList0 = new LinkedList<Chromosome>();\n      ElitisticListPopulation elitisticListPopulation0 = null;\n      \n        elitisticListPopulation0 = new ElitisticListPopulation(linkedList0, 2144375856, 2144375856);"
    },
    {
        "focal_method": "    public ElitisticListPopulation(final List<Chromosome> chromosomes,\n                                   final int populationLimit,\n                                   final double elitismRate) {\n        super(chromosomes, populationLimit);\n        this.elitismRate = elitismRate;\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      ElitisticListPopulation elitisticListPopulation0 = null;\n      try {\n        elitisticListPopulation0 = new ElitisticListPopulation(1905, (-146.889688));\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // elitism rate (-146.89)\n         //\n         verifyException(\"org.apache.commons.math3.genetics.ElitisticListPopulation\", e);\n      }\n  }",
        "docstring": "/**\n     * Creates a new ElitisticListPopulation instance.\n     *\n     * @param chromosomes list of chromosomes in the population\n     * @param populationLimit maximal size of the population\n     * @param elitismRate how many best chromosomes will be directly transferred to the\n     *                    next generation [in %]\n     * @throws OutOfRangeException if the elitism rate is outside the [0, 1] range\n     */",
        "id": "63",
        "project": "Math",
        "bug_num": "35",
        "test_name": "org.apache.commons.math3.genetics.ElitisticListPopulation_ESTest::test2",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "ElitisticListPopulation elitisticListPopulation0 = null;\n      \n        elitisticListPopulation0 = new ElitisticListPopulation(1905, (-146.889688));"
    },
    {
        "focal_method": "    public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n        super(rowDimension, columnDimension);\n        this.rows = rowDimension;\n        this.columns = columnDimension;\n        this.entries = new OpenIntToDoubleHashMap(0.0);\n    }",
        "test_prefix": "  public void test3()  throws Throwable  {\n      OpenMapRealMatrix openMapRealMatrix0 = null;\n      try {\n        openMapRealMatrix0 = new OpenMapRealMatrix(2141034748, Integer.MAX_VALUE);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // 4,597,837,108,988,765,956 is larger than, or equal to, the maximum (2,147,483,647)\n         //\n         verifyException(\"org.apache.commons.math.linear.OpenMapRealMatrix\", e);\n      }\n  }",
        "docstring": "/**\n     * Build a sparse matrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension Number of rows of the matrix.\n     * @param columnDimension Number of columns of the matrix.\n     */",
        "id": "64",
        "project": "Math",
        "bug_num": "45",
        "test_name": "org.apache.commons.math.linear.OpenMapRealMatrix_ESTest::test3",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "OpenMapRealMatrix openMapRealMatrix0 = null;\n      \n        openMapRealMatrix0 = new OpenMapRealMatrix(2141034748, Integer.MAX_VALUE);"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      double[] doubleArray0 = new double[6];\n      doubleArray0[2] = 1739.0314653;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BisectionSolver bisectionSolver0 = new BisectionSolver();\n      double double0 = bisectionSolver0.solve((UnivariateRealFunction) polynomialFunction0, (-2797.401695998948), (-1618.247285), (-1618.247285));\n      assertEquals(30, bisectionSolver0.getIterationCount());\n}",
        "docstring": "/** {@inheritDoc} */",
        "id": "65",
        "project": "Math",
        "bug_num": "70",
        "test_name": "org.apache.commons.math.analysis.solvers.BisectionSolver_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(0.0, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[6];\n      doubleArray0[2] = 1739.0314653;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BisectionSolver bisectionSolver0 = new BisectionSolver();\n      double double0 = bisectionSolver0.solve((UnivariateRealFunction) polynomialFunction0, (-2797.401695998948), (-1618.247285), (-1618.247285));"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      double[] doubleArray0 = new double[6];\n      doubleArray0[2] = 1739.0314653;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BisectionSolver bisectionSolver0 = new BisectionSolver();\n      double double0 = bisectionSolver0.solve((UnivariateRealFunction) polynomialFunction0, (-2797.401695998948), (-1618.247285), (-1618.247285));\n      assertEquals((-1618.2472852745432), double0, 0.01);\n}",
        "docstring": "/** {@inheritDoc} */",
        "id": "66",
        "project": "Math",
        "bug_num": "70",
        "test_name": "org.apache.commons.math.analysis.solvers.BisectionSolver_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(0.0, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[6];\n      doubleArray0[2] = 1739.0314653;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BisectionSolver bisectionSolver0 = new BisectionSolver();\n      double double0 = bisectionSolver0.solve((UnivariateRealFunction) polynomialFunction0, (-2797.401695998948), (-1618.247285), (-1618.247285));"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(f, min, max);\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      double[] doubleArray0 = new double[6];\n      doubleArray0[2] = 1739.0314653;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BisectionSolver bisectionSolver0 = new BisectionSolver();\n      double double0 = bisectionSolver0.solve((UnivariateRealFunction) polynomialFunction0, (-2797.401695998948), (-1618.247285), (-1618.247285));\n  }",
        "docstring": "/** {@inheritDoc} */",
        "id": "67",
        "project": "Math",
        "bug_num": "70",
        "test_name": "org.apache.commons.math.analysis.solvers.BisectionSolver_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(Double.NaN, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[6];\n      doubleArray0[2] = 1739.0314653;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BisectionSolver bisectionSolver0 = new BisectionSolver();\n      double double0 = bisectionSolver0.solve((UnivariateRealFunction) polynomialFunction0, (-2797.401695998948), (-1618.247285), (-1618.247285));"
    },
    {
        "focal_method": "    public static double[] bracket(UnivariateRealFunction function, \n            double initial, double lowerBound, double upperBound) \n    throws ConvergenceException, FunctionEvaluationException {\n        return bracket( function, initial, lowerBound, upperBound,\n            Integer.MAX_VALUE ) ;\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      double[] doubleArray0 = new double[3];\n      doubleArray0[0] = 4037.4646;\n      doubleArray0[1] = 283.42488442;\n      PolynomialFunctionLagrangeForm polynomialFunctionLagrangeForm0 = new PolynomialFunctionLagrangeForm(doubleArray0, doubleArray0);\n      double[] doubleArray1 = UnivariateRealSolverUtils.bracket((UnivariateRealFunction) polynomialFunctionLagrangeForm0, 855.1881, 0.0, 938.1475384);\n      assertArrayEquals(new double[] {0.0, 938.1475384}, doubleArray1, 0.01);\n}",
        "docstring": "/**\n     * This method attempts to find two values a and b satisfying <ul>\n    * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) < 0 </code></li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> Integer.MAX_VALUE</code> iterations elapse \n     * -- ConvergenceException </li>\n     * </ul></p>\n     * <p>\n     * <strong>Note: </strong> this method can take \n     * <code>Integer.MAX_VALUE</code> iterations to throw a \n     * <code>ConvergenceException.</code>  Unless you are confident that there\n     * is a root between <code>lowerBound</code> and <code>upperBound</code>\n     * near <code>initial,</code> it is better to use \n     * {@link #bracket(UnivariateRealFunction, double, double, double, int)}, \n     * explicitly specifying the maximum number of iterations.</p>\n     *\n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @return a two element array holding {a, b}\n     * @throws ConvergenceException if a root can not be bracketted\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */",
        "id": "68",
        "project": "Math",
        "bug_num": "85",
        "test_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertFalse(doubleArray1.equals(doubleArray0));",
        "prefix": "double[] doubleArray0 = new double[3];\n      doubleArray0[0] = 4037.4646;\n      doubleArray0[1] = 283.42488442;\n      PolynomialFunctionLagrangeForm polynomialFunctionLagrangeForm0 = new PolynomialFunctionLagrangeForm(doubleArray0, doubleArray0);\n      double[] doubleArray1 = UnivariateRealSolverUtils.bracket((UnivariateRealFunction) polynomialFunctionLagrangeForm0, 855.1881, 0.0, 938.1475384);"
    },
    {
        "focal_method": "    public static double[] bracket(UnivariateRealFunction function, \n            double initial, double lowerBound, double upperBound) \n    throws ConvergenceException, FunctionEvaluationException {\n        return bracket( function, initial, lowerBound, upperBound,\n            Integer.MAX_VALUE ) ;\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      double[] doubleArray0 = new double[3];\n      doubleArray0[0] = 4037.4646;\n      doubleArray0[1] = 283.42488442;\n      PolynomialFunctionLagrangeForm polynomialFunctionLagrangeForm0 = new PolynomialFunctionLagrangeForm(doubleArray0, doubleArray0);\n      double[] doubleArray1 = UnivariateRealSolverUtils.bracket((UnivariateRealFunction) polynomialFunctionLagrangeForm0, 855.1881, 0.0, 938.1475384);\n  }",
        "docstring": "/**\n     * This method attempts to find two values a and b satisfying <ul>\n    * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n     * <li> <code> f(a) * f(b) < 0 </code></li>\n     * </ul>\n     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n     * and <code>b</code> bracket a root of f.\n     * <p>\n     * The algorithm starts by setting \n     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n     * function at <code>a</code> and <code>b</code> and keeps moving\n     * the endpoints out by one unit each time through a loop that terminates \n     * when one of the following happens: <ul>\n     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n     * <li> <code> a = lower </code> and <code> b = upper</code> \n     * -- ConvergenceException </li>\n     * <li> <code> Integer.MAX_VALUE</code> iterations elapse \n     * -- ConvergenceException </li>\n     * </ul></p>\n     * <p>\n     * <strong>Note: </strong> this method can take \n     * <code>Integer.MAX_VALUE</code> iterations to throw a \n     * <code>ConvergenceException.</code>  Unless you are confident that there\n     * is a root between <code>lowerBound</code> and <code>upperBound</code>\n     * near <code>initial,</code> it is better to use \n     * {@link #bracket(UnivariateRealFunction, double, double, double, int)}, \n     * explicitly specifying the maximum number of iterations.</p>\n     *\n     * @param function the function\n     * @param initial initial midpoint of interval being expanded to\n     * bracket a root\n     * @param lowerBound lower bound (a is never lower than this value)\n     * @param upperBound upper bound (b never is greater than this\n     * value)\n     * @return a two element array holding {a, b}\n     * @throws ConvergenceException if a root can not be bracketted\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if function is null, maximumIterations\n     * is not positive, or initial is not between lowerBound and upperBound\n     */",
        "id": "69",
        "project": "Math",
        "bug_num": "85",
        "test_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertNotNull(doubleArray1);",
        "prefix": "double[] doubleArray0 = new double[3];\n      doubleArray0[0] = 4037.4646;\n      doubleArray0[1] = 283.42488442;\n      PolynomialFunctionLagrangeForm polynomialFunctionLagrangeForm0 = new PolynomialFunctionLagrangeForm(doubleArray0, doubleArray0);\n      double[] doubleArray1 = UnivariateRealSolverUtils.bracket((UnivariateRealFunction) polynomialFunctionLagrangeForm0, 855.1881, 0.0, 938.1475384);"
    },
    {
        "focal_method": "    public static int lcm(int a, int b) {\n        return Math.abs(mulAndCheck(a / gcd(a, b), b));\n    }",
        "test_prefix": "  public void test002()  throws Throwable  {\n      // Undeclared exception!\n      try { \n        MathUtils.lcm(1073741824, (-1216));\n        fail(\"Expecting exception: ArithmeticException\");\n      } catch(ArithmeticException e) {\n         //\n         // overflow: mul\n         //\n         verifyException(\"org.apache.commons.math.util.MathUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * Returns the least common multiple between two integer values.\n     * \n     * @param a the first integer value.\n     * @param b the second integer value.\n     * @return the least common multiple between a and b.\n     * @throws ArithmeticException if the lcm is too large to store as an int\n     * @since 1.1\n     */",
        "id": "70",
        "project": "Math",
        "bug_num": "94",
        "test_name": "org.apache.commons.math.util.MathUtils_ESTest::test002",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "// Undeclared exception!\n       \n        MathUtils.lcm(1073741824, (-1216));"
    },
    {
        "focal_method": "    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    new Object[] { p, q });\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }",
        "test_prefix": "  public void test061()  throws Throwable  {\n      // Undeclared exception!\n      try { \n        MathUtils.gcd(Integer.MIN_VALUE, 0);\n        fail(\"Expecting exception: ArithmeticException\");\n      } catch(ArithmeticException e) {\n         //\n         // overflow: gcd(-2,147,483,648, 0) is 2^31\n         //\n         verifyException(\"org.apache.commons.math.MathRuntimeException\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations\n     * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n     * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n     * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n     * <code>ArithmeticException</code>, because the result would be 2^31, which\n     * is too large for an int value.</li>\n     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n     * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n     * for the special cases above.\n     * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n     * <code>0</code>.</li>\n     * </ul>\n     * \n     * @param u any number\n     * @param v any number\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException\n     *             if the result cannot be represented as a nonnegative int\n     *             value\n     * @since 1.1\n     */",
        "id": "71",
        "project": "Math",
        "bug_num": "99",
        "test_name": "org.apache.commons.math.util.MathUtils_ESTest::test061",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "// Undeclared exception!\n       \n        MathUtils.gcd(Integer.MIN_VALUE, 0);"
    },
    {
        "focal_method": "    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    new Object[] { p, q });\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }",
        "test_prefix": "  public void test062()  throws Throwable  {\n      // Undeclared exception!\n      try { \n        MathUtils.gcd(0, Integer.MIN_VALUE);\n        fail(\"Expecting exception: ArithmeticException\");\n      } catch(ArithmeticException e) {\n         //\n         // overflow: gcd(0, -2,147,483,648) is 2^31\n         //\n         verifyException(\"org.apache.commons.math.MathRuntimeException\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations\n     * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n     * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n     * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n     * <code>ArithmeticException</code>, because the result would be 2^31, which\n     * is too large for an int value.</li>\n     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n     * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n     * for the special cases above.\n     * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n     * <code>0</code>.</li>\n     * </ul>\n     * \n     * @param u any number\n     * @param v any number\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException\n     *             if the result cannot be represented as a nonnegative int\n     *             value\n     * @since 1.1\n     */",
        "id": "72",
        "project": "Math",
        "bug_num": "99",
        "test_name": "org.apache.commons.math.util.MathUtils_ESTest::test062",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "// Undeclared exception!\n       \n        MathUtils.gcd(0, Integer.MIN_VALUE);"
    },
    {
        "focal_method": "    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        return lcm;\n    }",
        "test_prefix": "  public void test081()  throws Throwable  {\n      // Undeclared exception!\n      try { \n        MathUtils.lcm(4, Integer.MIN_VALUE);\n        fail(\"Expecting exception: ArithmeticException\");\n      } catch(ArithmeticException e) {\n         //\n         // overflow: lcm is 2^31\n         //\n         verifyException(\"org.apache.commons.math.util.MathUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>\n     * Returns the least common multiple of the absolute value of two numbers,\n     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and\n     * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n     * power of 2, throw an <code>ArithmeticException</code>, because the result\n     * would be 2^31, which is too large for an int value.</li>\n     * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is\n     * <code>0</code> for any <code>x</code>.\n     * </ul>\n     * \n     * @param a any number\n     * @param b any number\n     * @return the least common multiple, never negative\n     * @throws ArithmeticException\n     *             if the result cannot be represented as a nonnegative int\n     *             value\n     * @since 1.1\n     */",
        "id": "73",
        "project": "Math",
        "bug_num": "99",
        "test_name": "org.apache.commons.math.util.MathUtils_ESTest::test081",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "// Undeclared exception!\n       \n        MathUtils.lcm(4, Integer.MIN_VALUE);"
    },
    {
        "focal_method": "    public BrentOptimizer(double rel,\n                          double abs,\n                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      BrentOptimizer brentOptimizer0 = new BrentOptimizer(2202.502669393223, 2202.502669393223);\n      Logistic logistic0 = new Logistic(2202.502669393223, 2202.502669393223, 596, (-83.763), 596, 596);\n      GoalType goalType0 = GoalType.MINIMIZE;\n      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(596, (UnivariateFunction) logistic0, goalType0, 2.5339783209345245E8, (double) 596, (-2207.0263));\n      assertEquals((-2207.0263), univariatePointValuePair0.getPoint(), 0.01);\n}",
        "docstring": "/**\n     * The arguments are used implement the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param checker Additional, user-defined, convergence checking\n     * procedure.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */",
        "id": "74",
        "project": "Math",
        "bug_num": "23",
        "test_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertNotNull(univariatePointValuePair0);",
        "prefix": "BrentOptimizer brentOptimizer0 = new BrentOptimizer(2202.502669393223, 2202.502669393223);\n      Logistic logistic0 = new Logistic(2202.502669393223, 2202.502669393223, 596, (-83.763), 596, 596);\n      GoalType goalType0 = GoalType.MINIMIZE;\n      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(596, (UnivariateFunction) logistic0, goalType0, 2.5339783209345245E8, (double) 596, (-2207.0263));"
    },
    {
        "focal_method": "    public BrentOptimizer(double rel,\n                          double abs,\n                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }",
        "test_prefix": "  public void test6()  throws Throwable  {\n      BrentOptimizer brentOptimizer0 = new BrentOptimizer(5.8015881615938497E-8, 5.8015881615938497E-8);\n      Signum signum0 = new Signum();\n      GoalType goalType0 = GoalType.MAXIMIZE;\n      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(2146396205, (UnivariateFunction) signum0, goalType0, 0.5469118054664329, 0.5469118054664329, 1.9017692579836876E-4);\n      assertEquals(1.9017692579836876E-4, univariatePointValuePair0.getPoint(), 0.01);\n}",
        "docstring": "/**\n     * The arguments are used implement the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param checker Additional, user-defined, convergence checking\n     * procedure.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */",
        "id": "75",
        "project": "Math",
        "bug_num": "23",
        "test_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer_ESTest::test6",
        "except_pred": "0",
        "assert_pred": "assertNotNull(univariatePointValuePair0);",
        "prefix": "BrentOptimizer brentOptimizer0 = new BrentOptimizer(5.8015881615938497E-8, 5.8015881615938497E-8);\n      Signum signum0 = new Signum();\n      GoalType goalType0 = GoalType.MAXIMIZE;\n      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(2146396205, (UnivariateFunction) signum0, goalType0, 0.5469118054664329, 0.5469118054664329, 1.9017692579836876E-4);"
    },
    {
        "focal_method": "    public BrentOptimizer(double rel,\n                          double abs,\n                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }",
        "test_prefix": "  public void test7()  throws Throwable  {\n      BrentOptimizer brentOptimizer0 = new BrentOptimizer(1972.9354295246733, 1973.80211594);\n      Gaussian gaussian0 = new Gaussian(2047, 2047);\n      GoalType goalType0 = GoalType.MAXIMIZE;\n      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(1560, (UnivariateFunction) gaussian0, goalType0, (-1.9872713979884691E43), 0.06666666666666667, 0.06666666666666667);\n      assertEquals(0.06666666666666667, univariatePointValuePair0.getPoint(), 0.01);\n}",
        "docstring": "/**\n     * The arguments are used implement the original stopping criterion\n     * of Brent's algorithm.\n     * {@code abs} and {@code rel} define a tolerance\n     * {@code tol = rel |x| + abs}. {@code rel} should be no smaller than\n     * <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>,\n     * where <em>macheps</em> is the relative machine precision. {@code abs} must\n     * be positive.\n     *\n     * @param rel Relative threshold.\n     * @param abs Absolute threshold.\n     * @param checker Additional, user-defined, convergence checking\n     * procedure.\n     * @throws NotStrictlyPositiveException if {@code abs <= 0}.\n     * @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}.\n     */",
        "id": "76",
        "project": "Math",
        "bug_num": "23",
        "test_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer_ESTest::test7",
        "except_pred": "0",
        "assert_pred": "assertNotNull(univariatePointValuePair0);",
        "prefix": "BrentOptimizer brentOptimizer0 = new BrentOptimizer(1972.9354295246733, 1973.80211594);\n      Gaussian gaussian0 = new Gaussian(2047, 2047);\n      GoalType goalType0 = GoalType.MAXIMIZE;\n      UnivariatePointValuePair univariatePointValuePair0 = brentOptimizer0.optimize(1560, (UnivariateFunction) gaussian0, goalType0, (-1.9872713979884691E43), 0.06666666666666667, 0.06666666666666667);"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      double[] doubleArray0 = new double[6];\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      double double0 = brentSolver0.solve((-1689.2658367652516), 1.5);\n      assertEquals((-1689.2658367652516), double0, 0.01);\n}",
        "docstring": "/**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */",
        "id": "77",
        "project": "Math",
        "bug_num": "97",
        "test_name": "org.apache.commons.math.analysis.BrentSolver_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "assertEquals(0.0, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[6];\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      double double0 = brentSolver0.solve((-1689.2658367652516), 1.5);"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      double[] doubleArray0 = new double[6];\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      double double0 = brentSolver0.solve((-1689.2658367652516), 1.5);\n  }",
        "docstring": "/**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */",
        "id": "78",
        "project": "Math",
        "bug_num": "97",
        "test_name": "org.apache.commons.math.analysis.BrentSolver_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "assertEquals(0.0, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[6];\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      double double0 = brentSolver0.solve((-1689.2658367652516), 1.5);"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }",
        "test_prefix": "  public void test08()  throws Throwable  {\n      double[] doubleArray0 = new double[4];\n      doubleArray0[0] = 1.0E-14;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      brentSolver0.setFunctionValueAccuracy(1.0E-14);\n      double double0 = brentSolver0.solve((-859.8904), 1301.7162085317);\n      assertEquals((-859.8904), double0, 0.01);\n}",
        "docstring": "/**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */",
        "id": "79",
        "project": "Math",
        "bug_num": "97",
        "test_name": "org.apache.commons.math.analysis.BrentSolver_ESTest::test08",
        "except_pred": "0",
        "assert_pred": "assertEquals(Double.NaN, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[4];\n      doubleArray0[0] = 1.0E-14;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      brentSolver0.setFunctionValueAccuracy(1.0E-14);\n      double double0 = brentSolver0.solve((-859.8904), 1301.7162085317);"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }",
        "test_prefix": "  public void test08()  throws Throwable  {\n      double[] doubleArray0 = new double[4];\n      doubleArray0[0] = 1.0E-14;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      brentSolver0.setFunctionValueAccuracy(1.0E-14);\n      double double0 = brentSolver0.solve((-859.8904), 1301.7162085317);\n  }",
        "docstring": "/**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */",
        "id": "80",
        "project": "Math",
        "bug_num": "97",
        "test_name": "org.apache.commons.math.analysis.BrentSolver_ESTest::test08",
        "except_pred": "0",
        "assert_pred": "assertEquals(Double.NaN, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[4];\n      doubleArray0[0] = 1.0E-14;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      brentSolver0.setFunctionValueAccuracy(1.0E-14);\n      double double0 = brentSolver0.solve((-859.8904), 1301.7162085317);"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      double[] doubleArray0 = new double[5];\n      doubleArray0[2] = 1.0E-14;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      double double0 = brentSolver0.solve((-1.0), 1.0E-14);\n      assertEquals(1.0E-14, double0, 0.01);\n}",
        "docstring": "/**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */",
        "id": "81",
        "project": "Math",
        "bug_num": "97",
        "test_name": "org.apache.commons.math.analysis.BrentSolver_ESTest::test09",
        "except_pred": "0",
        "assert_pred": "assertEquals(0.0, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[5];\n      doubleArray0[2] = 1.0E-14;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      double double0 = brentSolver0.solve((-1.0), 1.0E-14);"
    },
    {
        "focal_method": "    public double solve(double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        if (((initial - min) * (max -initial)) < 0) {\n            throw new IllegalArgumentException(\"Initial guess is not in search\" +\n                      \" interval.\" + \"  Initial: \" + initial +\n                      \"  Endpoints: [\" + min + \",\" + max + \"]\");\n        }\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(min, yMin, max, yMax, initial, yInitial);\n\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      double[] doubleArray0 = new double[5];\n      doubleArray0[2] = 1.0E-14;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      double double0 = brentSolver0.solve((-1.0), 1.0E-14);\n  }",
        "docstring": "/**\n     * Find a zero in the given interval with an initial guess.\n     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n     * function at the three points have the same sign (note that it is\n     * allowed to have endpoints with the same sign if the initial point has\n     * opposite sign function-wise).</p>\n     * \n     * @param min the lower bound for the interval.\n     * @param max the upper bound for the interval.\n     * @param initial the start value to use (must be set to min if no\n     * initial point is known).\n     * @return the value where the function is zero\n     * @throws MaxIterationsExceededException the maximum iteration count\n     * is exceeded \n     * @throws FunctionEvaluationException if an error occurs evaluating\n     *  the function\n     * @throws IllegalArgumentException if initial is not between min and max\n     * (even if it <em>is</em> a root)\n     */",
        "id": "82",
        "project": "Math",
        "bug_num": "97",
        "test_name": "org.apache.commons.math.analysis.BrentSolver_ESTest::test09",
        "except_pred": "0",
        "assert_pred": "assertEquals(0.0, double0, 0.01D);",
        "prefix": "double[] doubleArray0 = new double[5];\n      doubleArray0[2] = 1.0E-14;\n      PolynomialFunction polynomialFunction0 = new PolynomialFunction(doubleArray0);\n      BrentSolver brentSolver0 = new BrentSolver(polynomialFunction0);\n      double double0 = brentSolver0.solve((-1.0), 1.0E-14);"
    },
    {
        "focal_method": "    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      FDistributionImpl fDistributionImpl0 = new FDistributionImpl(763.683107623722, 1225.931330739);\n      fDistributionImpl0.setDenominatorDegreesOfFreedom(1.0);\n      double double0 = fDistributionImpl0.getInitialDomain((-942.0));\n      assertEquals(1.0, double0, 0.01);\n}",
        "docstring": "/**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */",
        "id": "83",
        "project": "Math",
        "bug_num": "95",
        "test_name": "org.apache.commons.math.distribution.FDistributionImpl_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertEquals(763.683107623722, double0, 0.01D);",
        "prefix": "FDistributionImpl fDistributionImpl0 = new FDistributionImpl(763.683107623722, 1225.931330739);\n      fDistributionImpl0.setDenominatorDegreesOfFreedom(1.0);\n      double double0 = fDistributionImpl0.getInitialDomain((-942.0));"
    },
    {
        "focal_method": "    public List getValues(final Option option,\n                          List defaultValues) {\n        // initialize the return list\n        List valueList = (List) values.get(option);\n\n        // grab the correct default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = defaultValues;\n        }\n\n        // augment the list with the default values\n        if ((valueList == null) || valueList.isEmpty()) {\n            valueList = (List) this.defaultValues.get(option);\n        }\n                // if there are more default values as specified, add them to\n                // the list.\n                    // copy the list first\n        \n        return valueList == null ? Collections.EMPTY_LIST : valueList;\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();\n      PropertyOption propertyOption0 = PropertyOption.INSTANCE;\n      WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);\n      List list0 = writeableCommandLineImpl0.getOptions();\n      FileValidator fileValidator0 = FileValidator.getExistingDirectoryInstance();\n      ArgumentImpl argumentImpl0 = new ArgumentImpl(\"[af`YR\", \"DJ;%\", 124, 124, 'I', 'I', fileValidator0, \"Option.missing.required\", list0, 124);\n      writeableCommandLineImpl0.addSwitch(argumentImpl0, false);\n      writeableCommandLineImpl0.addValue(argumentImpl0, \"Option.missing.required\");\n      List list1 = writeableCommandLineImpl0.getValues((Option) argumentImpl0, (List) list0);\n      assertEquals(2, list1.size());\n}",
        "docstring": "",
        "id": "84",
        "project": "Cli",
        "bug_num": "15",
        "test_name": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl_ESTest::test12",
        "except_pred": "0",
        "assert_pred": "assertEquals(1, list1.size());",
        "prefix": "LinkedList<PropertyOption> linkedList0 = new LinkedList<PropertyOption>();\n      PropertyOption propertyOption0 = PropertyOption.INSTANCE;\n      WriteableCommandLineImpl writeableCommandLineImpl0 = new WriteableCommandLineImpl(propertyOption0, linkedList0);\n      List list0 = writeableCommandLineImpl0.getOptions();\n      FileValidator fileValidator0 = FileValidator.getExistingDirectoryInstance();\n      ArgumentImpl argumentImpl0 = new ArgumentImpl(\"[af`YR\", \"DJ;%\", 124, 124, 'I', 'I', fileValidator0, \"Option.missing.required\", list0, 124);\n      writeableCommandLineImpl0.addSwitch(argumentImpl0, false);\n      writeableCommandLineImpl0.addValue(argumentImpl0, \"Option.missing.required\");\n      List list1 = writeableCommandLineImpl0.getValues((Option) argumentImpl0, (List) list0);"
    },
    {
        "focal_method": "    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }",
        "test_prefix": "  public void test26()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      StringBuffer stringBuffer0 = new StringBuffer();\n      Options options0 = new Options();\n      Options options1 = options0.addOption(\"t\", false, \"--\");\n      helpFormatter0.renderOptions(stringBuffer0, 68, options1, 144, 1);\n      assertEquals(37, stringBuffer0.length());\n}",
        "docstring": "/**\n     * Render the specified Options and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed\n     * to each line\n     * @param descPad the number of characters of padding to be prefixed\n     * to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */",
        "id": "85",
        "project": "Cli",
        "bug_num": "25",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test26",
        "except_pred": "0",
        "assert_pred": "assertEquals(68, stringBuffer0.length());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      StringBuffer stringBuffer0 = new StringBuffer();\n      Options options0 = new Options();\n      Options options1 = options0.addOption(\"t\", false, \"--\");\n      helpFormatter0.renderOptions(stringBuffer0, 68, options1, 144, 1);"
    },
    {
        "focal_method": "    public void printWrapped(PrintWriter pw, int width, String text)\n    {\n        printWrapped(pw, width, 0, text);\n    }",
        "test_prefix": "  public void test28()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(\"arg\");\n      helpFormatter0.printWrapped((PrintWriter) mockPrintWriter0, 0, \"[ Options: [ short \");\n  }",
        "docstring": "/**\n     * Print the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */",
        "id": "86",
        "project": "Cli",
        "bug_num": "25",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test28",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, mockPrintWriter0.checkError());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(\"arg\");\n      helpFormatter0.printWrapped((PrintWriter) mockPrintWriter0, 0, \"[ Options: [ short \");"
    },
    {
        "focal_method": "    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        if (str.startsWith(\"\\\"\"))\n        {\n            str = str.substring(1, str.length());\n        }\n        int length = str.length();\n        if (str.endsWith(\"\\\"\"))\n        {\n            str = str.substring(0, length - 1);\n        }\n        \n        return str;\n    }",
        "test_prefix": "  public void test6()  throws Throwable  {\n      String string0 = Util.stripLeadingAndTrailingQuotes(\"\\\"qDxD_5>q,)`dEgM\");\n      assertEquals(\"\\\"qDxD_5>q,)`dEgM\", string0);\n}",
        "docstring": "/**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */",
        "id": "87",
        "project": "Cli",
        "bug_num": "29",
        "test_name": "org.apache.commons.cli.Util_ESTest::test6",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\\\"qDxD_5>q,)`dEgM\", string0);",
        "prefix": "String string0 = Util.stripLeadingAndTrailingQuotes(\"\\\"qDxD_5>q,)`dEgM\");"
    },
    {
        "focal_method": "    static String stripLeadingAndTrailingQuotes(String str)\n    {\n        if (str.startsWith(\"\\\"\"))\n        {\n            str = str.substring(1, str.length());\n        }\n        int length = str.length();\n        if (str.endsWith(\"\\\"\"))\n        {\n            str = str.substring(0, length - 1);\n        }\n        \n        return str;\n    }",
        "test_prefix": "  public void test8()  throws Throwable  {\n      String string0 = Util.stripLeadingAndTrailingQuotes(\"\\\"\\\" |B_#\\\"\");\n      assertEquals(\"\\\"\\\" |B_#\\\"\", string0);\n}",
        "docstring": "/**\n     * Remove the leading and trailing quotes from <code>str</code>.\n     * E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes\n     * should be removed.\n     *\n     * @return The string without the leading and trailing quotes.\n     */",
        "id": "88",
        "project": "Cli",
        "bug_num": "29",
        "test_name": "org.apache.commons.cli.Util_ESTest::test8",
        "except_pred": "0",
        "assert_pred": "assertNotNull(string0);",
        "prefix": "String string0 = Util.stripLeadingAndTrailingQuotes(\"\\\"\\\" |B_#\\\"\");"
    },
    {
        "focal_method": "    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }",
        "test_prefix": "  public void test32()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(\"opt contains illegal character value '\");\n      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 8, \"opt contains illegal character value '\");\n      assertEquals(74, helpFormatter0.defaultWidth);\n}",
        "docstring": "/**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */",
        "id": "89",
        "project": "Cli",
        "bug_num": "24",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test32",
        "except_pred": "0",
        "assert_pred": "assertEquals(8, mockPrintWriter0.size());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(\"opt contains illegal character value '\");\n      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 8, \"opt contains illegal character value '\");"
    },
    {
        "focal_method": "    public void printUsage(PrintWriter pw, int width, String app, Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, getOptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }",
        "test_prefix": "  public void test32()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(\"opt contains illegal character value '\");\n      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 8, \"opt contains illegal character value '\");\n  }",
        "docstring": "/**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */",
        "id": "90",
        "project": "Cli",
        "bug_num": "24",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test32",
        "except_pred": "0",
        "assert_pred": "assertEquals(8, mockPrintWriter0.size());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(\"opt contains illegal character value '\");\n      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 8, \"opt contains illegal character value '\");"
    },
    {
        "focal_method": "    public static Object createValue(final String str, final Object obj) throws ParseException\n    {\n        return createValue(str, (Class<?>) obj);\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      Class<Integer> class0 = Integer.class;\n      try { \n        TypeHandler.createValue(\"uo7{tEV1yjof\", class0);\n        fail(\"Expecting exception: Exception\");\n      } catch(Exception e) {\n         //\n         // Unable to handle the class: class java.lang.Integer\n         //\n         verifyException(\"org.apache.commons.cli.TypeHandler\", e);\n      }\n  }",
        "docstring": "/**\n     * Returns the <code>Object</code> of type <code>obj</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param obj the type of argument\n     * @return The instance of <code>obj</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given object type failed\n     */",
        "id": "91",
        "project": "Cli",
        "bug_num": "40",
        "test_name": "org.apache.commons.cli.TypeHandler_ESTest::test10",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "Class<Integer> class0 = Integer.class;\n       \n        TypeHandler.createValue(\"uo7{tEV1yjof\", class0);"
    },
    {
        "focal_method": "    static String stripLeadingHyphens(String str)\n    {\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      String string0 = Util.stripLeadingHyphens((String) null);\n      assertNull(string0);\n}",
        "docstring": "/**\n     * <p>Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.</p>\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */",
        "id": "92",
        "project": "Cli",
        "bug_num": "5",
        "test_name": "org.apache.commons.cli.Util_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertNull(string0);",
        "prefix": "String string0 = Util.stripLeadingHyphens((String) null);"
    },
    {
        "focal_method": "    static String stripLeadingHyphens(String str)\n    {\n        if (str.startsWith(\"--\"))\n        {\n            return str.substring(2, str.length());\n        }\n        else if (str.startsWith(\"-\"))\n        {\n            return str.substring(1, str.length());\n        }\n\n        return str;\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      String string0 = Util.stripLeadingHyphens((String) null);\n  }",
        "docstring": "/**\n     * <p>Remove the hyphens from the begining of <code>str</code> and\n     * return the new String.</p>\n     *\n     * @param str The string from which the hyphens should be removed.\n     *\n     * @return the new String.\n     */",
        "id": "93",
        "project": "Cli",
        "bug_num": "5",
        "test_name": "org.apache.commons.cli.Util_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertNull(string0);",
        "prefix": "String string0 = Util.stripLeadingHyphens((String) null);"
    },
    {
        "focal_method": "    public void printUsage(PrintWriter pw, int width, String app, \n                           Options options)\n    {\n        // initialise the string buffer\n        StringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n                                                                 .append(\" \");\n\n        // create a list for processed option groups\n        final Collection processedGroups = new ArrayList();\n\n        // temp variable\n        Option option;\n\n        List optList = new ArrayList(options.getOptions());\n        Collections.sort(optList, new OptionComparator());\n        // iterate over the options\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            // get the next Option\n            option = (Option) i.next();\n\n            // check if the option is part of an OptionGroup\n            OptionGroup group = options.getOptionGroup(option);\n\n            // if the option is part of a group \n            if (group != null)\n            {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group))\n                {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n\n\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n\n            // if the Option is not part of an OptionGroup\n            else\n            {\n                appendOption(buff, option, option.isRequired());\n            }\n\n            if (i.hasNext())\n            {\n                buff.append(\" \");\n            }\n        }\n\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, \n                     buff.toString());\n    }",
        "test_prefix": "  public void test27()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(\"-\");\n      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 0, \"[ Options: [ sh6ort \");\n  }",
        "docstring": "/**\n     * <p>Prints the usage statement for the specified application.</p>\n     *\n     * @param pw The PrintWriter to print the usage statement \n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     *\n     */",
        "id": "94",
        "project": "Cli",
        "bug_num": "8",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test27",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, mockPrintWriter0.checkError());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      MockPrintWriter mockPrintWriter0 = new MockPrintWriter(\"-\");\n      helpFormatter0.printUsage((PrintWriter) mockPrintWriter0, 0, \"[ Options: [ sh6ort \");"
    },
    {
        "focal_method": "    public String getLongOptPrefix()\n    {\n        return defaultLongOptPrefix;\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"\\n\", \"\\n\", options0, \"6i4?l\");\n      assertEquals(\"--\", helpFormatter0.getLongOptPrefix());\n}",
        "docstring": "/**\n     * Returns the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */",
        "id": "95",
        "project": "Cli",
        "bug_num": "32",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test24",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"6i4?\", helpFormatter0.getLongOptPrefix());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"\\n\", \"\\n\", options0, \"6i4?l\");"
    },
    {
        "focal_method": "    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"\\n\", \"\\n\", options0, \"6i4?l\");\n  }",
        "docstring": "/**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */",
        "id": "96",
        "project": "Cli",
        "bug_num": "32",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test24",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, options0.isSet());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"\\n\", \"\\n\", options0, \"6i4?l\");"
    },
    {
        "focal_method": "    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"-<e6=M|IgIm9wEy]?Rk\", \" \", options0, \" \");\n      assertEquals(74, helpFormatter0.defaultWidth);\n}",
        "docstring": "/**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */",
        "id": "97",
        "project": "Cli",
        "bug_num": "32",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, helpFormatter0.printHelp());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"-<e6=M|IgIm9wEy]?Rk\", \" \", options0, \" \");"
    },
    {
        "focal_method": "    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"-<e6=M|IgIm9wEy]?Rk\", \" \", options0, \" \");\n      assertEquals(3, helpFormatter0.defaultDescPad);\n}",
        "docstring": "/**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */",
        "id": "98",
        "project": "Cli",
        "bug_num": "32",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, helpFormatter0.printHelp());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"-<e6=M|IgIm9wEy]?Rk\", \" \", options0, \" \");"
    },
    {
        "focal_method": "    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"-<e6=M|IgIm9wEy]?Rk\", \" \", options0, \" \");\n  }",
        "docstring": "/**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */",
        "id": "99",
        "project": "Cli",
        "bug_num": "32",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, helpFormatter0.printHelp());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(2, \"-<e6=M|IgIm9wEy]?Rk\", \" \", options0, \" \");"
    },
    {
        "focal_method": "    public Object getType()\n    {\n        return type;\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      Option option0 = new Option(\"\", \"\", true, \"'\");\n      Object object0 = option0.getType();\n      assertNotNull(object0);\n}",
        "docstring": "/**\n     * Retrieve the type of this Option.\n     * \n     * @return The type of this option\n     */",
        "id": "100",
        "project": "Cli",
        "bug_num": "34",
        "test_name": "org.apache.commons.cli.Option_ESTest::test09",
        "except_pred": "0",
        "assert_pred": "assertNull(object0);",
        "prefix": "Option option0 = new Option(\"\", \"\", true, \"'\");\n      Object object0 = option0.getType();"
    },
    {
        "focal_method": "    public String toString()\n    {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      Option option0 = new Option(\"\", \"\");\n      option0.setArgs((-2));\n      String string0 = option0.toString();\n      assertEquals(\"[ option:  [ARG...] ::  :: class java.lang.String ]\", string0);\n}",
        "docstring": "/** \n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */",
        "id": "101",
        "project": "Cli",
        "bug_num": "34",
        "test_name": "org.apache.commons.cli.Option_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"[ option: -2 ]\", string0);",
        "prefix": "Option option0 = new Option(\"\", \"\");\n      option0.setArgs((-2));\n      String string0 = option0.toString();"
    },
    {
        "focal_method": "    public String toString()\n    {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }",
        "test_prefix": "  public void test33()  throws Throwable  {\n      Option option0 = new Option(\"\", \"X84U-w?C*\", true, \"\");\n      String string0 = option0.toString();\n      assertEquals(\"[ option:  X84U-w?C*  [ARG] ::  :: class java.lang.String ]\", string0);\n}",
        "docstring": "/** \n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */",
        "id": "102",
        "project": "Cli",
        "bug_num": "34",
        "test_name": "org.apache.commons.cli.Option_ESTest::test33",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"[ option: X84U-w?C* ]\", string0);",
        "prefix": "Option option0 = new Option(\"\", \"X84U-w?C*\", true, \"\");\n      String string0 = option0.toString();"
    },
    {
        "focal_method": "    public String toString()\n    {\n        StringBuffer buf = new StringBuffer().append(\"[ option: \");\n\n        buf.append(opt);\n\n        if (longOpt != null)\n        {\n            buf.append(\" \").append(longOpt);\n        }\n\n        buf.append(\" \");\n\n        if (hasArgs())\n        {\n            buf.append(\"[ARG...]\");\n        }\n        else if (hasArg())\n        {\n            buf.append(\" [ARG]\");\n        }\n\n        buf.append(\" :: \").append(description);\n\n        if (type != null)\n        {\n            buf.append(\" :: \").append(type);\n        }\n\n        buf.append(\" ]\");\n\n        return buf.toString();\n    }",
        "test_prefix": "  public void test34()  throws Throwable  {\n      Option option0 = new Option(\"\", \"\");\n      String string0 = option0.toString();\n      assertEquals(\"[ option:   ::  :: class java.lang.String ]\", string0);\n}",
        "docstring": "/** \n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */",
        "id": "103",
        "project": "Cli",
        "bug_num": "34",
        "test_name": "org.apache.commons.cli.Option_ESTest::test34",
        "except_pred": "0",
        "assert_pred": "assertNotNull(string0);",
        "prefix": "Option option0 = new Option(\"\", \"\");\n      String string0 = option0.toString();"
    },
    {
        "focal_method": "    public void printHelp(String cmdLineSyntax, Options options)\n    {\n        printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n    }",
        "test_prefix": "  public void test29()  throws Throwable  {\n      HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(1, \"\\n\", \"arg\", options0, \"--\");\n  }",
        "docstring": "/**\n     * Print the help for <code>options</code> with the specified\n     * command line syntax.  This method prints help information to\n     * System.out.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */",
        "id": "104",
        "project": "Cli",
        "bug_num": "23",
        "test_name": "org.apache.commons.cli.HelpFormatter_ESTest::test29",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, options0.isSet());",
        "prefix": "HelpFormatter helpFormatter0 = new HelpFormatter();\n      Options options0 = new Options();\n      helpFormatter0.printHelp(1, \"\\n\", \"arg\", options0, \"--\");"
    },
    {
        "focal_method": "    public boolean hasArgName()\n    {\n        return argName != null && argName.length() > 0;\n    }",
        "test_prefix": "  public void test20()  throws Throwable  {\n      Option option0 = new Option(\"4\", \"4\");\n      boolean boolean0 = option0.hasArgName();\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n     * Returns whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */",
        "id": "105",
        "project": "Cli",
        "bug_num": "31",
        "test_name": "org.apache.commons.cli.Option_ESTest::test20",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Option option0 = new Option(\"4\", \"4\");\n      boolean boolean0 = option0.hasArgName();"
    },
    {
        "focal_method": "    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                int tokenLength = token.length();\n\n                if (tokenLength == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else\n            {\n                if (stopAtNonOption)\n                {\n                    process(token);\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }",
        "test_prefix": "  public void test3()  throws Throwable  {\n      PosixParser posixParser0 = new PosixParser();\n      Options options0 = new Options();\n      String[] stringArray0 = new String[2];\n      stringArray0[0] = \"-ub\\\"vdz(*j\";\n      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);\n      assertEquals(3, stringArray1.length);\n}",
        "docstring": "/**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */",
        "id": "106",
        "project": "Cli",
        "bug_num": "17",
        "test_name": "org.apache.commons.cli.PosixParser_ESTest::test3",
        "except_pred": "0",
        "assert_pred": "assertNotSame(stringArray1, stringArray0);",
        "prefix": "PosixParser posixParser0 = new PosixParser();\n      Options options0 = new Options();\n      String[] stringArray0 = new String[2];\n      stringArray0[0] = \"-ub\\\"vdz(*j\";\n      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);"
    },
    {
        "focal_method": "    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                int pos = token.indexOf('=');\n                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                if (!options.hasOption(opt))\n                {\n                    processNonOptionToken(token);\n                }\n                else\n                {\n                    \n                    tokens.add(opt);\n                    if (pos != -1)\n                    {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2 || options.hasOption(token))\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                processNonOptionToken(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }",
        "test_prefix": "  public void test1()  throws Throwable  {\n      PosixParser posixParser0 = new PosixParser();\n      Options options0 = new Options();\n      String[] stringArray0 = new String[6];\n      stringArray0[0] = \"-PE---\";\n      stringArray0[1] = \"\";\n      stringArray0[2] = \"\";\n      stringArray0[3] = \"A CloneNotSupportedExceptionwas thown: \";\n      stringArray0[4] = \"--eA_{'~R[w=`\";\n      // Undeclared exception!\n      try { \n        posixParser0.flatten(options0, stringArray0, false);\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n      }\n  }",
        "docstring": "/**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of\n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see\n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled\n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */",
        "id": "107",
        "project": "Cli",
        "bug_num": "22",
        "test_name": "org.apache.commons.cli.PosixParser_ESTest::test1",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "PosixParser posixParser0 = new PosixParser();\n      Options options0 = new Options();\n      String[] stringArray0 = new String[6];\n      stringArray0[0] = \"-PE---\";\n      stringArray0[1] = \"\";\n      stringArray0[2] = \"\";\n      stringArray0[3] = \"A CloneNotSupportedExceptionwas thown: \";\n      stringArray0[4] = \"--eA_{'~R[w=`\";\n      // Undeclared exception!\n       \n        posixParser0.flatten(options0, stringArray0, false);"
    },
    {
        "focal_method": "    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle long option --foo or --foo=bar\n            if (token.startsWith(\"--\"))\n            {\n                int pos = token.indexOf('=');\n                String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                if (!options.hasOption(opt))\n                {\n                    processNonOptionToken(token);\n                }\n                else\n                {\n                    \n                    tokens.add(opt);\n                    if (pos != -1)\n                    {\n                        tokens.add(token.substring(pos + 1));\n                    }\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                tokens.add(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2 || options.hasOption(token))\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                processNonOptionToken(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      PosixParser posixParser0 = new PosixParser();\n      Options options0 = new Options();\n      options0.addOption(\"P\", true, \"T\");\n      String[] stringArray0 = new String[4];\n      stringArray0[0] = \"-PE---\";\n      stringArray0[1] = \"-8\";\n      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);\n      String[] stringArray2 = posixParser0.flatten(options0, stringArray1, true);\n      assertEquals(5, stringArray2.length);\n}",
        "docstring": "/**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of\n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see\n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled\n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */",
        "id": "108",
        "project": "Cli",
        "bug_num": "22",
        "test_name": "org.apache.commons.cli.PosixParser_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertNotSame(stringArray1, stringArray2);",
        "prefix": "PosixParser posixParser0 = new PosixParser();\n      Options options0 = new Options();\n      options0.addOption(\"P\", true, \"T\");\n      String[] stringArray0 = new String[4];\n      stringArray0[0] = \"-PE---\";\n      stringArray0[1] = \"-8\";\n      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);\n      String[] stringArray2 = posixParser0.flatten(options0, stringArray1, true);"
    },
    {
        "focal_method": "    protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n    {\n        init();\n        this.options = options;\n\n        // an iterator for the command line tokens\n        Iterator iter = Arrays.asList(arguments).iterator();\n\n        // process each command line token\n        while (iter.hasNext())\n        {\n            // get the next command line token\n            String token = (String) iter.next();\n\n            // handle SPECIAL TOKEN\n            if (token.startsWith(\"--\"))\n            {\n                if (token.indexOf('=') != -1)\n                {\n                    tokens.add(token.substring(0, token.indexOf('=')));\n                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n                }\n                else\n                {\n                    tokens.add(token);\n                }\n            }\n\n            // single hyphen\n            else if (\"-\".equals(token))\n            {\n                processSingleHyphen(token);\n            }\n            else if (token.startsWith(\"-\"))\n            {\n                if (token.length() == 2)\n                {\n                    processOptionToken(token, stopAtNonOption);\n                }\n                else if (options.hasOption(token))\n                {\n                    tokens.add(token);\n                }\n                // requires bursting\n                else\n                {\n                    burstToken(token, stopAtNonOption);\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token);\n            }\n            else\n            {\n                tokens.add(token);\n            }\n\n            gobble(iter);\n        }\n\n        return (String[]) tokens.toArray(new String[tokens.size()]);\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      PosixParser posixParser0 = new PosixParser();\n      Options options0 = new Options();\n      String[] stringArray0 = new String[2];\n      stringArray0[0] = \"- \";\n      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);\n      assertEquals(2, stringArray1.length);\n}",
        "docstring": "/**\n     * <p>An implementation of {@link Parser}'s abstract\n     * {@link Parser#flatten(Options,String[],boolean) flatten} method.</p>\n     *\n     * <p>The following are the rules used by this flatten method.\n     * <ol>\n     *  <li>if <code>stopAtNonOption</code> is <b>true</b> then do not\n     *  burst anymore of <code>arguments</code> entries, just add each\n     *  successive entry without further processing.  Otherwise, ignore\n     *  <code>stopAtNonOption</code>.</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>--</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is \"<b>-</b>\"\n     *  just add the entry to the list of processed tokens</li>\n     *  <li>if the current <code>arguments</code> entry is two characters\n     *  in length and the first character is \"<b>-</b>\" then check if this\n     *  is a valid {@link Option} id.  If it is a valid id, then add the\n     *  entry to the list of processed tokens and set the current {@link Option}\n     *  member.  If it is not a valid id and <code>stopAtNonOption</code>\n     *  is true, then the remaining entries are copied to the list of \n     *  processed tokens.  Otherwise, the current entry is ignored.</li>\n     *  <li>if the current <code>arguments</code> entry is more than two\n     *  characters in length and the first character is \"<b>-</b>\" then\n     *  we need to burst the entry to determine its constituents.  For more\n     *  information on the bursting algorithm see \n     *  {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     *  <li>if the current <code>arguments</code> entry is not handled \n     *  by any of the previous rules, then the entry is added to the list\n     *  of processed tokens.</li>\n     * </ol>\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening\n     * when an non option is found.\n     * @return The flattened <code>arguments</code> String array.\n     */",
        "id": "109",
        "project": "Cli",
        "bug_num": "18",
        "test_name": "org.apache.commons.cli.PosixParser_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertNotSame(stringArray1, stringArray0);",
        "prefix": "PosixParser posixParser0 = new PosixParser();\n      Options options0 = new Options();\n      String[] stringArray0 = new String[2];\n      stringArray0[0] = \"- \";\n      String[] stringArray1 = posixParser0.flatten(options0, stringArray0, true);"
    },
    {
        "focal_method": "    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }",
        "test_prefix": "  public void test11()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('q');\n      assertTrue(cSVFormat1.getAllowMissingColumnNames());\n}",
        "docstring": "/**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */",
        "id": "110",
        "project": "Csv",
        "bug_num": "12",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test11",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, cSVFormat1.getAllowMissingColumnNames());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('q');"
    },
    {
        "focal_method": "    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('y');\n      boolean boolean0 = cSVFormat0.equals(cSVFormat1);\n      assertTrue(cSVFormat1.getAllowMissingColumnNames());\n}",
        "docstring": "/**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */",
        "id": "111",
        "project": "Csv",
        "bug_num": "12",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, cSVFormat0.getAllowMissingColumnNames());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker('y');\n      boolean boolean0 = cSVFormat0.equals(cSVFormat1);"
    },
    {
        "focal_method": "    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }",
        "test_prefix": "  public void test29()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      CSVFormat cSVFormat1 = cSVFormat0.withNullString(\"The comment start and the escape character cannot be the same ('\");\n      cSVFormat1.equals(cSVFormat0);\n      assertTrue(cSVFormat1.getAllowMissingColumnNames());\n}",
        "docstring": "/**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */",
        "id": "112",
        "project": "Csv",
        "bug_num": "12",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test29",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, cSVFormat0.getAllowMissingColumnNames());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      CSVFormat cSVFormat1 = cSVFormat0.withNullString(\"The comment start and the escape character cannot be the same ('\");\n      cSVFormat1.equals(cSVFormat0);"
    },
    {
        "focal_method": "    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }",
        "test_prefix": "  public void test33()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      String[] stringArray0 = new String[3];\n      stringArray0[1] = \"The header contains a duplicate entry: '\";\n      stringArray0[2] = \"c[0TyZhMn}#&:L\";\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      cSVFormat1.format(stringArray0);\n      assertTrue(cSVFormat1.getAllowMissingColumnNames());\n}",
        "docstring": "/**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */",
        "id": "113",
        "project": "Csv",
        "bug_num": "12",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test33",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, cSVFormat0.getAllowMissingColumnNames());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      String[] stringArray0 = new String[3];\n      stringArray0[1] = \"The header contains a duplicate entry: '\";\n      stringArray0[2] = \"c[0TyZhMn}#&:L\";\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      cSVFormat1.format(stringArray0);"
    },
    {
        "focal_method": "    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }",
        "test_prefix": "  public void test35()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.DEFAULT;\n      CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(\"\");\n      cSVFormat1.hashCode();\n      assertTrue(cSVFormat1.getAllowMissingColumnNames());\n}",
        "docstring": "/**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */",
        "id": "114",
        "project": "Csv",
        "bug_num": "12",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test35",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, cSVFormat0.getAllowMissingColumnNames());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.DEFAULT;\n      CSVFormat cSVFormat1 = cSVFormat0.EXCEL.withNullString(\"\");\n      cSVFormat1.hashCode();"
    },
    {
        "focal_method": "    public boolean getAllowMissingColumnNames() {\n        return allowMissingColumnNames;\n    }",
        "test_prefix": "  public void test40()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      String[] stringArray0 = new String[3];\n      stringArray0[1] = \"The header contains a duplicate entry: '\";\n      stringArray0[2] = \"c[0TyZhMn}#&:L\";\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      String string0 = cSVFormat1.toString();\n      assertTrue(cSVFormat1.getAllowMissingColumnNames());\n}",
        "docstring": "/**\n     * Specifies whether missing column names are allowed when parsing the header line.\n     *\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an\n     *         {@link IllegalArgumentException}.\n     */",
        "id": "115",
        "project": "Csv",
        "bug_num": "12",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test40",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, cSVFormat0.getAllowMissingColumnNames());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.EXCEL;\n      String[] stringArray0 = new String[3];\n      stringArray0[1] = \"The header contains a duplicate entry: '\";\n      stringArray0[2] = \"c[0TyZhMn}#&:L\";\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      String string0 = cSVFormat1.toString();"
    },
    {
        "focal_method": "    public CSVFormat withHeader(final String... header) {\n        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.TDF;\n      String[] stringArray0 = new String[4];\n      // Undeclared exception!\n      try { \n        cSVFormat0.DEFAULT.withHeader(stringArray0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // The header contains a duplicate entry: 'null' in [null, null, null, null]\n         //\n         verifyException(\"org.apache.commons.csv.CSVFormat\", e);\n      }\n  }",
        "docstring": "/**\n     * Sets the header of the format. The header can either be parsed automatically from the input file with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader();</pre>\n     *\n     * or specified manually with:\n     *\n     * <pre>\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);</pre>\n     *\n     * @param header\n     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n     *\n     * @return A new CSVFormat that is equal to this but with the specified header\n     * @see #withSkipHeaderRecord(boolean)\n     */",
        "id": "116",
        "project": "Csv",
        "bug_num": "8",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test12",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.TDF;\n      String[] stringArray0 = new String[4];\n      // Undeclared exception!\n       \n        cSVFormat0.DEFAULT.withHeader(stringArray0);"
    },
    {
        "focal_method": "    public String getNullString() {\n        return nullString;\n    }",
        "test_prefix": "  public void test02()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      QuoteMode quoteMode0 = QuoteMode.MINIMAL;\n      CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);\n      cSVFormat1.hashCode();\n      assertEquals(\"\\\\N\", cSVFormat1.getNullString());\n}",
        "docstring": "/**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */",
        "id": "117",
        "project": "Csv",
        "bug_num": "13",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test02",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\\\"\\\"\", cSVFormat1.getNullString());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      QuoteMode quoteMode0 = QuoteMode.MINIMAL;\n      CSVFormat cSVFormat1 = cSVFormat0.withQuoteMode(quoteMode0);\n      cSVFormat1.hashCode();"
    },
    {
        "focal_method": "    public String getNullString() {\n        return nullString;\n    }",
        "test_prefix": "  public void test11()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();\n      assertEquals(\"\\\\N\", cSVFormat1.getNullString());\n}",
        "docstring": "/**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */",
        "id": "118",
        "project": "Csv",
        "bug_num": "13",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test11",
        "except_pred": "0",
        "assert_pred": "assertNull(cSVFormat1.getNullString());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      CSVFormat cSVFormat1 = cSVFormat0.withIgnoreEmptyLines();"
    },
    {
        "focal_method": "    public String getNullString() {\n        return nullString;\n    }",
        "test_prefix": "  public void test21()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      CSVFormat cSVFormat1 = cSVFormat0.withQuote('c');\n      boolean boolean0 = cSVFormat0.equals(cSVFormat1);\n      assertEquals(\"\\\\N\", cSVFormat1.getNullString());\n}",
        "docstring": "/**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */",
        "id": "119",
        "project": "Csv",
        "bug_num": "13",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test21",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"c\", cSVFormat0.getNullString());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      CSVFormat cSVFormat1 = cSVFormat0.withQuote('c');\n      boolean boolean0 = cSVFormat0.equals(cSVFormat1);"
    },
    {
        "focal_method": "    public String getNullString() {\n        return nullString;\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      Character character0 = Character.valueOf('8');\n      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);\n      boolean boolean0 = cSVFormat1.equals(cSVFormat0);\n      assertEquals(\"\\\\N\", cSVFormat1.getNullString());\n}",
        "docstring": "/**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */",
        "id": "120",
        "project": "Csv",
        "bug_num": "13",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\", cSVFormat0.getNullString());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      Character character0 = Character.valueOf('8');\n      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);\n      boolean boolean0 = cSVFormat1.equals(cSVFormat0);"
    },
    {
        "focal_method": "    public String getNullString() {\n        return nullString;\n    }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      Character character0 = Character.valueOf('8');\n      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);\n      CSVFormat cSVFormat2 = cSVFormat1.withEscape('?');\n      boolean boolean0 = cSVFormat1.equals(cSVFormat2);\n      assertEquals(\"\\\\N\", cSVFormat2.getNullString());\n}",
        "docstring": "/**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */",
        "id": "121",
        "project": "Csv",
        "bug_num": "13",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"?\", cSVFormat1.getNullString());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      Character character0 = Character.valueOf('8');\n      CSVFormat cSVFormat1 = cSVFormat0.withCommentMarker(character0);\n      CSVFormat cSVFormat2 = cSVFormat1.withEscape('?');\n      boolean boolean0 = cSVFormat1.equals(cSVFormat2);"
    },
    {
        "focal_method": "    public String getNullString() {\n        return nullString;\n    }",
        "test_prefix": "  public void test33()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('$');\n      cSVFormat0.equals(cSVFormat1);\n      assertEquals(\"\\\\N\", cSVFormat1.getNullString());\n}",
        "docstring": "/**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */",
        "id": "122",
        "project": "Csv",
        "bug_num": "13",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test33",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\", cSVFormat0.getNullString());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      CSVFormat cSVFormat1 = cSVFormat0.withRecordSeparator('$');\n      cSVFormat0.equals(cSVFormat1);"
    },
    {
        "focal_method": "    public String getNullString() {\n        return nullString;\n    }",
        "test_prefix": "  public void test34()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      String[] stringArray0 = new String[0];\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      cSVFormat1.getHeader();\n      assertEquals(\"\\\\N\", cSVFormat1.getNullString());\n}",
        "docstring": "/**\n     * Gets the String to convert to and from {@code null}.\n     * <ul>\n     * <li>\n     * <strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading\n     * records.</li>\n     * <li>\n     * <strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\n     * </ul>\n     *\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}\n     */",
        "id": "123",
        "project": "Csv",
        "bug_num": "13",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test34",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\", cSVFormat1.getNullString());",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      String[] stringArray0 = new String[0];\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      cSVFormat1.getHeader();"
    },
    {
        "focal_method": "    public String toString() {\n        final StringBuilder sb = new StringBuilder();\n        sb.append(\"Delimiter=<\").append(delimiter).append('>');\n        if (isEscapeCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n        }\n        if (isQuoteCharacterSet()) {\n            sb.append(' ');\n            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n        }\n        if (isCommentMarkerSet()) {\n            sb.append(' ');\n            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n        }\n        if (isNullStringSet()) {\n            sb.append(' ');\n            sb.append(\"NullString=<\").append(nullString).append('>');\n        }\n        if (recordSeparator != null) {\n            sb.append(' ');\n            sb.append(\"RecordSeparator=<\").append(recordSeparator).append('>');\n        }\n        if (getIgnoreEmptyLines()) {\n            sb.append(\" EmptyLines:ignored\");\n        }\n        if (getIgnoreSurroundingSpaces()) {\n            sb.append(\" SurroundingSpaces:ignored\");\n        }\n        if (getIgnoreHeaderCase()) {\n            sb.append(\" IgnoreHeaderCase:ignored\");\n        }\n        sb.append(\" SkipHeaderRecord:\").append(skipHeaderRecord);\n        if (headerComments != null) {\n            sb.append(' ');\n            sb.append(\"HeaderComments:\").append(Arrays.toString(headerComments));\n        }\n        if (header != null) {\n            sb.append(' ');\n            sb.append(\"Header:\").append(Arrays.toString(header));\n        }\n        return sb.toString();\n    }",
        "test_prefix": "  public void test45()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      String[] stringArray0 = new String[0];\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      String string0 = cSVFormat1.toString();\n      assertEquals(\"Delimiter=<\\t> Escape=<\\\\> NullString=<\\\\N> RecordSeparator=<\\n> SkipHeaderRecord:false Header:[]\", string0);\n}",
        "docstring": "",
        "id": "124",
        "project": "Csv",
        "bug_num": "13",
        "test_name": "org.apache.commons.csv.CSVFormat_ESTest::test45",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"Delimiter=<null>\", string0);",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.MYSQL;\n      String[] stringArray0 = new String[0];\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      String string0 = cSVFormat1.toString();"
    },
    {
        "focal_method": "    public void print(final Object value) throws IOException {\n        // null values are considered empty\n        String strValue;\n        if (value == null) {\n            final String nullString = format.getNullString();\n            strValue = nullString == null ? Constants.EMPTY : nullString;\n        } else {\n            strValue = value.toString();\n        }\n        this.print(value, strValue, 0, strValue.length());\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.TDF;\n      String[] stringArray0 = new String[1];\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      Quote quote0 = Quote.NON_NUMERIC;\n      CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);\n      PipedWriter pipedWriter0 = new PipedWriter();\n      try { \n        cSVFormat2.print(pipedWriter0);\n        fail(\"Expecting exception: IOException\");\n      } catch(IOException e) {\n         //\n         // Pipe not connected\n         //\n         verifyException(\"java.io.PipedWriter\", e);\n      }\n  }",
        "docstring": "/**\n     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n     *\n     * @param value\n     *            value to be output.\n     * @throws IOException\n     *             If an I/O error occurs\n     */",
        "id": "125",
        "project": "Csv",
        "bug_num": "10",
        "test_name": "org.apache.commons.csv.CSVPrinter_ESTest::test09",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.TDF;\n      String[] stringArray0 = new String[1];\n      CSVFormat cSVFormat1 = cSVFormat0.withHeader(stringArray0);\n      Quote quote0 = Quote.NON_NUMERIC;\n      CSVFormat cSVFormat2 = cSVFormat1.withQuotePolicy(quote0);\n      PipedWriter pipedWriter0 = new PipedWriter();\n       \n        cSVFormat2.print(pipedWriter0);"
    },
    {
        "focal_method": "    public long getRecordNumber() {\n        return recordNumber;\n    }",
        "test_prefix": "  public void test17()  throws Throwable  {\n      HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();\n      Integer integer0 = new Integer(854);\n      hashMap0.put((String) null, integer0);\n      String[] stringArray0 = new String[0];\n      CSVRecord cSVRecord0 = new CSVRecord(stringArray0, hashMap0, (String) null, 854);\n      cSVRecord0.toMap();\n      assertEquals(854L, cSVRecord0.getRecordNumber());\n}",
        "docstring": "/**\n     * Returns the number of this record in the parsed CSV file.\n     *\n     * @return the number of this record.\n     */",
        "id": "126",
        "project": "Csv",
        "bug_num": "6",
        "test_name": "org.apache.commons.csv.CSVRecord_ESTest::test17",
        "except_pred": "0",
        "assert_pred": "assertEquals(854L, cSVRecord0.getRecordNumber());",
        "prefix": "HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();\n      Integer integer0 = new Integer(854);\n      hashMap0.put((String) null, integer0);\n      String[] stringArray0 = new String[0];\n      CSVRecord cSVRecord0 = new CSVRecord(stringArray0, hashMap0, (String) null, 854);\n      cSVRecord0.toMap();"
    },
    {
        "focal_method": "    public Map<String, String> toMap() {\n        return putIn(new HashMap<String, String>(values.length));\n    }",
        "test_prefix": "  public void test17()  throws Throwable  {\n      HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();\n      Integer integer0 = new Integer(854);\n      hashMap0.put((String) null, integer0);\n      String[] stringArray0 = new String[0];\n      CSVRecord cSVRecord0 = new CSVRecord(stringArray0, hashMap0, (String) null, 854);\n      cSVRecord0.toMap();\n  }",
        "docstring": "/**\n     * Copies this record into a new Map. The new map is not connect\n     *\n     * @return A new Map. The map is empty if the record has no headers.\n     */",
        "id": "127",
        "project": "Csv",
        "bug_num": "6",
        "test_name": "org.apache.commons.csv.CSVRecord_ESTest::test17",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"{null=854}\", cSVRecord0.toString());",
        "prefix": "HashMap<String, Integer> hashMap0 = new HashMap<String, Integer>();\n      Integer integer0 = new Integer(854);\n      hashMap0.put((String) null, integer0);\n      String[] stringArray0 = new String[0];\n      CSVRecord cSVRecord0 = new CSVRecord(stringArray0, hashMap0, (String) null, 854);\n      cSVRecord0.toMap();"
    },
    {
        "focal_method": "    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n                return c;\n            // indicate unexpected char - available from in.getLastChar()\n        }\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      CSVFormat cSVFormat0 = CSVFormat.DEFAULT;\n      StringReader stringReader0 = new StringReader(\"QU,rs$@LR&/\");\n      ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);\n      CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);\n      cSVLexer0.readEscape();\n      int int0 = cSVLexer0.readEscape();\n      assertEquals((-1), int0);\n}",
        "docstring": "/**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */",
        "id": "128",
        "project": "Csv",
        "bug_num": "3",
        "test_name": "org.apache.commons.csv.Lexer_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertEquals(1, int0);",
        "prefix": "CSVFormat cSVFormat0 = CSVFormat.DEFAULT;\n      StringReader stringReader0 = new StringReader(\"QU,rs$@LR&/\");\n      ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);\n      CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);\n      cSVLexer0.readEscape();\n      int int0 = cSVLexer0.readEscape();"
    },
    {
        "focal_method": "    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        case CR:\n        case LF:\n        case FF: // TODO is this correct?\n        case TAB: // TODO is this correct? Do tabs need to be escaped?\n        case BACKSPACE: // TODO is this correct?\n            return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Now check for meta-characters\n                return c;\n            // indicate unexpected char - available from in.getLastChar()\n        }\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      StringReader stringReader0 = new StringReader(\"org.apache.commons.csv.CSVLexer\");\n      Character character0 = new Character('\\'');\n      Quote quote0 = Quote.ALL;\n      Character character1 = new Character('a');\n      String[] stringArray0 = new String[1];\n      CSVFormat cSVFormat0 = new CSVFormat('$', character0, quote0, character1, character0, false, true, \"org.apache.commons.csv.CSVLexer\", (String) null, stringArray0);\n      ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);\n      CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);\n      cSVLexer0.readEscape();\n      int int0 = cSVLexer0.readEscape();\n      int int1 = cSVLexer0.readEscape();\n      assertEquals((-1), int1);\n}",
        "docstring": "/**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     * \n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n     * the escape character is not allowed at end of strem\n     */",
        "id": "129",
        "project": "Csv",
        "bug_num": "3",
        "test_name": "org.apache.commons.csv.Lexer_ESTest::test10",
        "except_pred": "0",
        "assert_pred": "assertTrue(cSVLexer0.equals(cSVLexer0));",
        "prefix": "StringReader stringReader0 = new StringReader(\"org.apache.commons.csv.CSVLexer\");\n      Character character0 = new Character('\\'');\n      Quote quote0 = Quote.ALL;\n      Character character1 = new Character('a');\n      String[] stringArray0 = new String[1];\n      CSVFormat cSVFormat0 = new CSVFormat('$', character0, quote0, character1, character0, false, true, \"org.apache.commons.csv.CSVLexer\", (String) null, stringArray0);\n      ExtendedBufferedReader extendedBufferedReader0 = new ExtendedBufferedReader(stringReader0);\n      CSVLexer cSVLexer0 = new CSVLexer(cSVFormat0, extendedBufferedReader0);\n      cSVLexer0.readEscape();\n      int int0 = cSVLexer0.readEscape();\n      int int1 = cSVLexer0.readEscape();"
    },
    {
        "focal_method": "    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      BigInteger bigInteger0 = BigInteger.ONE;\n      byte[] byteArray0 = Base64.encodeInteger(bigInteger0);\n      Base64 base64_0 = new Base64();\n      byte[] byteArray1 = base64_0.encode(byteArray0);\n      int int0 = base64_0.readResults(byteArray1, (byte)90, (byte) (-1));\n      assertArrayEquals(new byte[] {(byte)81, (byte)86, (byte)69, (byte)57, (byte)80, (byte)81, (byte)61, (byte)61}, byteArray1);\n}",
        "docstring": "/**\n     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * \n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @return The number of bytes successfully extracted into the provided byte[] array.\n     */",
        "id": "130",
        "project": "Codec",
        "bug_num": "4",
        "test_name": "org.apache.commons.codec.binary.Base64_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, int0);",
        "prefix": "BigInteger bigInteger0 = BigInteger.ONE;\n      byte[] byteArray0 = Base64.encodeInteger(bigInteger0);\n      Base64 base64_0 = new Base64();\n      byte[] byteArray1 = base64_0.encode(byteArray0);\n      int int0 = base64_0.readResults(byteArray1, (byte)90, (byte) (-1));"
    },
    {
        "focal_method": "    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.baseNCodec = baseNCodec;\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      byte[] byteArray0 = new byte[12];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 4096, 597);\n      Base64 base64_0 = new Base64(597);\n      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base64_0, false);\n      // Undeclared exception!\n      try { \n        baseNCodecInputStream0.skip((-3161L));\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Negative skip length\n         //\n         verifyException(\"org.apache.commons.codec.binary.BaseNCodecInputStream\", e);\n      }\n  }",
        "docstring": "",
        "id": "131",
        "project": "Codec",
        "bug_num": "12",
        "test_name": "org.apache.commons.codec.binary.BaseNCodecInputStream_ESTest::test09",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[12];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 4096, 597);\n      Base64 base64_0 = new Base64(597);\n      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base64_0, false);\n      // Undeclared exception!\n       \n        baseNCodecInputStream0.skip((-3161L));"
    },
    {
        "focal_method": "    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.baseNCodec = baseNCodec;\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      byte[] byteArray0 = new byte[1];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 4096, 597);\n      Base64 base64_0 = new Base64((-2146420536));\n      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base64_0, true);\n      long long0 = baseNCodecInputStream0.skip(597);\n      assertEquals(0L, long0);\n}",
        "docstring": "",
        "id": "132",
        "project": "Codec",
        "bug_num": "12",
        "test_name": "org.apache.commons.codec.binary.BaseNCodecInputStream_ESTest::test10",
        "except_pred": "0",
        "assert_pred": "assertEquals(4, byteArrayInputStream0.available());",
        "prefix": "byte[] byteArray0 = new byte[1];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, 4096, 597);\n      Base64 base64_0 = new Base64((-2146420536));\n      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base64_0, true);\n      long long0 = baseNCodecInputStream0.skip(597);"
    },
    {
        "focal_method": "    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.baseNCodec = baseNCodec;\n    }",
        "test_prefix": "  public void test11()  throws Throwable  {\n      byte[] byteArray0 = new byte[3];\n      Base32 base32_0 = new Base32();\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);\n      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false);\n      int int0 = baseNCodecInputStream0.available();\n      assertEquals(1, int0);\n}",
        "docstring": "",
        "id": "133",
        "project": "Codec",
        "bug_num": "12",
        "test_name": "org.apache.commons.codec.binary.BaseNCodecInputStream_ESTest::test11",
        "except_pred": "0",
        "assert_pred": "assertEquals(3, int0);",
        "prefix": "byte[] byteArray0 = new byte[3];\n      Base32 base32_0 = new Base32();\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);\n      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false);\n      int int0 = baseNCodecInputStream0.available();"
    },
    {
        "focal_method": "    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {\n        super(in);\n        this.doEncode = doEncode;\n        this.baseNCodec = baseNCodec;\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      byte[] byteArray0 = new byte[3];\n      Base32 base32_0 = new Base32();\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);\n      base32_0.encodeToString(byteArray0);\n      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false);\n      int int0 = baseNCodecInputStream0.available();\n      assertEquals(0, int0);\n}",
        "docstring": "",
        "id": "134",
        "project": "Codec",
        "bug_num": "12",
        "test_name": "org.apache.commons.codec.binary.BaseNCodecInputStream_ESTest::test12",
        "except_pred": "0",
        "assert_pred": "assertEquals(3, int0);",
        "prefix": "byte[] byteArray0 = new byte[3];\n      Base32 base32_0 = new Base32();\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);\n      base32_0.encodeToString(byteArray0);\n      BaseNCodecInputStream baseNCodecInputStream0 = new BaseNCodecInputStream(byteArrayInputStream0, base32_0, false);\n      int int0 = baseNCodecInputStream0.available();"
    },
    {
        "focal_method": "    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n        buffer.write(ESCAPE_CHAR);\n        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n        buffer.write(hex1);\n        buffer.write(hex2);\n    }",
        "test_prefix": "  public void test04()  throws Throwable  {\n      byte[] byteArray0 = new byte[9];\n      byteArray0[6] = (byte)9;\n      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);\n      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);\n      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);\n      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);\n      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);\n      assertEquals(90, byteArray3.length);\n}",
        "docstring": "/**\n     * Encodes byte into its quoted-printable representation.\n     * \n     * @param b\n     *            byte to encode\n     * @param buffer\n     *            the buffer to write to\n     * @return The number of bytes written to the <code>buffer</code>\n     */",
        "id": "135",
        "project": "Codec",
        "bug_num": "11",
        "test_name": "org.apache.commons.codec.net.QuotedPrintableCodec_ESTest::test04",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[9];\n      byteArray0[6] = (byte)9;\n      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);\n      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);\n      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);\n      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);\n      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);"
    },
    {
        "focal_method": "    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n        buffer.write(ESCAPE_CHAR);\n        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n        buffer.write(hex1);\n        buffer.write(hex2);\n    }",
        "test_prefix": "  public void test05()  throws Throwable  {\n      byte[] byteArray0 = new byte[9];\n      byteArray0[1] = (byte) (-18);\n      byteArray0[2] = (byte)1;\n      byteArray0[3] = (byte)9;\n      byteArray0[4] = (byte) (-18);\n      byteArray0[5] = (byte)96;\n      byteArray0[6] = (byte)9;\n      byteArray0[8] = (byte)16;\n      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);\n      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);\n      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);\n      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);\n      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);\n      byte[] byteArray4 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray3);\n      assertEquals(166, byteArray4.length);\n}",
        "docstring": "/**\n     * Encodes byte into its quoted-printable representation.\n     * \n     * @param b\n     *            byte to encode\n     * @param buffer\n     *            the buffer to write to\n     * @return The number of bytes written to the <code>buffer</code>\n     */",
        "id": "136",
        "project": "Codec",
        "bug_num": "11",
        "test_name": "org.apache.commons.codec.net.QuotedPrintableCodec_ESTest::test05",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[9];\n      byteArray0[1] = (byte) (-18);\n      byteArray0[2] = (byte)1;\n      byteArray0[3] = (byte)9;\n      byteArray0[4] = (byte) (-18);\n      byteArray0[5] = (byte)96;\n      byteArray0[6] = (byte)9;\n      byteArray0[8] = (byte)16;\n      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);\n      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);\n      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);\n      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);\n      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);\n      byte[] byteArray4 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray3);"
    },
    {
        "focal_method": "    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n        buffer.write(ESCAPE_CHAR);\n        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n        buffer.write(hex1);\n        buffer.write(hex2);\n    }",
        "test_prefix": "  public void test06()  throws Throwable  {\n      byte[] byteArray0 = new byte[9];\n      byteArray0[0] = (byte)53;\n      byteArray0[1] = (byte) (-18);\n      byteArray0[2] = (byte)1;\n      byteArray0[5] = (byte)96;\n      byteArray0[6] = (byte)9;\n      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);\n      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);\n      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);\n      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);\n      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);\n      assertEquals(80, byteArray3.length);\n}",
        "docstring": "/**\n     * Encodes byte into its quoted-printable representation.\n     * \n     * @param b\n     *            byte to encode\n     * @param buffer\n     *            the buffer to write to\n     * @return The number of bytes written to the <code>buffer</code>\n     */",
        "id": "137",
        "project": "Codec",
        "bug_num": "11",
        "test_name": "org.apache.commons.codec.net.QuotedPrintableCodec_ESTest::test06",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[9];\n      byteArray0[0] = (byte)53;\n      byteArray0[1] = (byte) (-18);\n      byteArray0[2] = (byte)1;\n      byteArray0[5] = (byte)96;\n      byteArray0[6] = (byte)9;\n      ByteBuffer byteBuffer0 = ByteBuffer.wrap(byteArray0);\n      BitSet bitSet0 = BitSet.valueOf(byteBuffer0);\n      byte[] byteArray1 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray0);\n      byte[] byteArray2 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray1);\n      byte[] byteArray3 = QuotedPrintableCodec.encodeQuotedPrintable(bitSet0, byteArray2);"
    },
    {
        "focal_method": "    public byte[] encode(byte[] bytes) {\n        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      QuotedPrintableCodec quotedPrintableCodec0 = new QuotedPrintableCodec();\n      byte[] byteArray0 = new byte[4];\n      byteArray0[3] = (byte)9;\n      byte[] byteArray1 = quotedPrintableCodec0.encode(byteArray0);\n      assertEquals(12, byteArray1.length);\n}",
        "docstring": "/**\n     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5)\n     * as defined in RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     * \n     * @param bytes\n     *                  array of bytes to be encoded\n     * @return array of bytes containing quoted-printable data\n     */",
        "id": "138",
        "project": "Codec",
        "bug_num": "11",
        "test_name": "org.apache.commons.codec.net.QuotedPrintableCodec_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertFalse(byteArray0.equals(byteArray1));",
        "prefix": "QuotedPrintableCodec quotedPrintableCodec0 = new QuotedPrintableCodec();\n      byte[] byteArray0 = new byte[4];\n      byteArray0[3] = (byte)9;\n      byte[] byteArray1 = quotedPrintableCodec0.encode(byteArray0);"
    },
    {
        "focal_method": "    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    // if the next octet is a CR we have found a soft line break\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                }\n            } else {\n                // every other octet is appended except for CR & LF\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      byte[] byteArray0 = new byte[7];\n      byteArray0[0] = (byte)61;\n      byteArray0[1] = (byte)13;\n      byte[] byteArray1 = QuotedPrintableCodec.decodeQuotedPrintable(byteArray0);\n      assertArrayEquals(new byte[] {(byte)0, (byte)0, (byte)0, (byte)0, (byte)0}, byteArray1);\n}",
        "docstring": "/**\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are\n     * converted back to their original representation.\n     *\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     * </p>\n     *\n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     */",
        "id": "139",
        "project": "Codec",
        "bug_num": "11",
        "test_name": "org.apache.commons.codec.net.QuotedPrintableCodec_ESTest::test09",
        "except_pred": "0",
        "assert_pred": "assertNotNull(byteArray1);",
        "prefix": "byte[] byteArray0 = new byte[7];\n      byteArray0[0] = (byte)61;\n      byteArray0[1] = (byte)13;\n      byte[] byteArray1 = QuotedPrintableCodec.decodeQuotedPrintable(byteArray0);"
    },
    {
        "focal_method": "    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    // if the next octet is a CR we have found a soft line break\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                }\n            } else {\n                // every other octet is appended except for CR & LF\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      byte[] byteArray0 = new byte[7];\n      byteArray0[0] = (byte)61;\n      byteArray0[1] = (byte)13;\n      byte[] byteArray1 = QuotedPrintableCodec.decodeQuotedPrintable(byteArray0);\n  }",
        "docstring": "/**\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are\n     * converted back to their original representation.\n     *\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     * </p>\n     *\n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     */",
        "id": "140",
        "project": "Codec",
        "bug_num": "11",
        "test_name": "org.apache.commons.codec.net.QuotedPrintableCodec_ESTest::test09",
        "except_pred": "0",
        "assert_pred": "assertNotNull(byteArray1);",
        "prefix": "byte[] byteArray0 = new byte[7];\n      byteArray0[0] = (byte)61;\n      byteArray0[1] = (byte)13;\n      byte[] byteArray1 = QuotedPrintableCodec.decodeQuotedPrintable(byteArray0);"
    },
    {
        "focal_method": "    public byte[] decode(byte[] bytes) throws DecoderException {\n        return decodeQuotedPrintable(bytes);\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      QuotedPrintableCodec quotedPrintableCodec0 = new QuotedPrintableCodec();\n      byte[] byteArray0 = new byte[3];\n      byteArray0[1] = (byte)13;\n      byte[] byteArray1 = quotedPrintableCodec0.decode(byteArray0);\n      assertArrayEquals(new byte[] {(byte)0, (byte)0}, byteArray1);\n}",
        "docstring": "/**\n     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * \n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #2)\n     * as defined in RFC 1521.\n     * </p>\n     * \n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     */",
        "id": "141",
        "project": "Codec",
        "bug_num": "11",
        "test_name": "org.apache.commons.codec.net.QuotedPrintableCodec_ESTest::test10",
        "except_pred": "0",
        "assert_pred": "assertFalse(byteArray0.equals(byteArray1));",
        "prefix": "QuotedPrintableCodec quotedPrintableCodec0 = new QuotedPrintableCodec();\n      byte[] byteArray0 = new byte[3];\n      byteArray0[1] = (byte)13;\n      byte[] byteArray1 = quotedPrintableCodec0.decode(byteArray0);"
    },
    {
        "focal_method": "    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n        if (bytes == null) {\n            return null;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            final int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    // if the next octet is a CR we have found a soft line break\n                    int u = Utils.digit16(bytes[++i]);\n                    int l = Utils.digit16(bytes[++i]);\n                    buffer.write((char) ((u << 4) + l));\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n                }\n            } else {\n                // every other octet is appended except for CR & LF\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
        "test_prefix": "  public void test11()  throws Throwable  {\n      byte[] byteArray0 = new byte[4];\n      byteArray0[1] = (byte)10;\n      byte[] byteArray1 = QuotedPrintableCodec.decodeQuotedPrintable(byteArray0);\n      assertArrayEquals(new byte[] {(byte)0, (byte)0, (byte)0}, byteArray1);\n}",
        "docstring": "/**\n     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are\n     * converted back to their original representation.\n     *\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     * </p>\n     *\n     * @param bytes\n     *                  array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *                  Thrown if quoted-printable decoding is unsuccessful\n     */",
        "id": "142",
        "project": "Codec",
        "bug_num": "11",
        "test_name": "org.apache.commons.codec.net.QuotedPrintableCodec_ESTest::test11",
        "except_pred": "0",
        "assert_pred": "assertNotNull(byteArray1);",
        "prefix": "byte[] byteArray0 = new byte[4];\n      byteArray0[1] = (byte)10;\n      byte[] byteArray1 = QuotedPrintableCodec.decodeQuotedPrintable(byteArray0);"
    },
    {
        "focal_method": "    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }",
        "test_prefix": "  public void test19()  throws Throwable  {\n      char[] charArray0 = new char[0];\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      boolean boolean0 = StringUtils.equals((CharSequence) charBuffer0, (CharSequence) \"\\uFFFD\");\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */",
        "id": "143",
        "project": "Codec",
        "bug_num": "18",
        "test_name": "org.apache.commons.codec.binary.StringUtils_ESTest::test19",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "char[] charArray0 = new char[0];\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      boolean boolean0 = StringUtils.equals((CharSequence) charBuffer0, (CharSequence) \"\\uFFFD\");"
    },
    {
        "focal_method": "    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }",
        "test_prefix": "  public void test19()  throws Throwable  {\n      char[] charArray0 = new char[0];\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      boolean boolean0 = StringUtils.equals((CharSequence) charBuffer0, (CharSequence) \"\\uFFFD\");\n  }",
        "docstring": "/**\n     * <p>\n     * Compares two CharSequences, returning <code>true</code> if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * <code>null</code>s are handled without exceptions. Two <code>null</code> references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */",
        "id": "144",
        "project": "Codec",
        "bug_num": "18",
        "test_name": "org.apache.commons.codec.binary.StringUtils_ESTest::test19",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "char[] charArray0 = new char[0];\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      boolean boolean0 = StringUtils.equals((CharSequence) charBuffer0, (CharSequence) \"\\uFFFD\");"
    },
    {
        "focal_method": "    public String toString() {\n        return outerHtml();\n    }",
        "test_prefix": "  public void test1()  throws Throwable  {\n      XmlDeclaration xmlDeclaration0 = new XmlDeclaration(\"t4N7&Q\", \"NW91EkPm \", false);\n      String string0 = xmlDeclaration0.toString();\n      assertEquals(\"<?t4N7&Q?>\", string0);\n}",
        "docstring": "",
        "id": "145",
        "project": "Jsoup",
        "bug_num": "52",
        "test_name": "org.jsoup.nodes.XmlDeclaration_ESTest::test1",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"t4N7&Q\", string0);",
        "prefix": "XmlDeclaration xmlDeclaration0 = new XmlDeclaration(\"t4N7&Q\", \"NW91EkPm \", false);\n      String string0 = xmlDeclaration0.toString();"
    },
    {
        "focal_method": "    public String getWholeDeclaration() {\n        final String decl = this.name;\n        if(decl.equals(\"xml\") && attributes.size() > 1 ) {\n            StringBuilder sb = new StringBuilder(decl);\n            final String version = attributes.get(\"version\");\n            if( version != null ) {\n                sb.append(\" version=\\\"\").append(version).append(\"\\\"\");\n            }\n            final String encoding = attributes.get(\"encoding\");\n            if( encoding != null ) {\n                sb.append(\" encoding=\\\"\").append(encoding).append(\"\\\"\");\n            }\n            return sb.toString();\n        }\n        else {\n            return this.name;\n        }\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      XmlDeclaration xmlDeclaration0 = new XmlDeclaration(\"n/(:P!,Rl&n<F63$O\", \"n/(:P!,Rl&n<F63$O\", false);\n      String string0 = xmlDeclaration0.getWholeDeclaration();\n      assertEquals(\"\", string0);\n}",
        "docstring": "/**\n     Get the unencoded XML declaration.\n     @return XML declaration\n     */",
        "id": "146",
        "project": "Jsoup",
        "bug_num": "52",
        "test_name": "org.jsoup.nodes.XmlDeclaration_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"n/(:P!,Rl&n<F63$O\", string0);",
        "prefix": "XmlDeclaration xmlDeclaration0 = new XmlDeclaration(\"n/(:P!,Rl&n<F63$O\", \"n/(:P!,Rl&n<F63$O\", false);\n      String string0 = xmlDeclaration0.getWholeDeclaration();"
    },
    {
        "focal_method": "    public String toString() {\n        return outerHtml();\n    }",
        "test_prefix": "  public void test3()  throws Throwable  {\n      XmlDeclaration xmlDeclaration0 = new XmlDeclaration(\"\", \"\", true);\n      String string0 = xmlDeclaration0.toString();\n      assertEquals(\"<!!>\", string0);\n}",
        "docstring": "",
        "id": "147",
        "project": "Jsoup",
        "bug_num": "52",
        "test_name": "org.jsoup.nodes.XmlDeclaration_ESTest::test3",
        "except_pred": "0",
        "assert_pred": "assertNotNull(string0);",
        "prefix": "XmlDeclaration xmlDeclaration0 = new XmlDeclaration(\"\", \"\", true);\n      String string0 = xmlDeclaration0.toString();"
    },
    {
        "focal_method": "    static String escape(String string, Document.OutputSettings out) {\n        return escape(string, out.encoder(), out.escapeMode());\n    }",
        "test_prefix": "  public void test3()  throws Throwable  {\n      Charset charset0 = Charset.defaultCharset();\n      CharsetEncoder charsetEncoder0 = charset0.newEncoder();\n      Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.extended;\n      String string0 = Entities.escape(\"Fo%^]N={*!BXG'NZQ\", charsetEncoder0, entities_EscapeMode0);\n      assertEquals(\"Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ\", string0);\n}",
        "docstring": "",
        "id": "148",
        "project": "Jsoup",
        "bug_num": "4",
        "test_name": "org.jsoup.nodes.Entities_ESTest::test3",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"Fo%^]N={*!BXG'NZQ\", string0);",
        "prefix": "Charset charset0 = Charset.defaultCharset();\n      CharsetEncoder charsetEncoder0 = charset0.newEncoder();\n      Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.extended;\n      String string0 = Entities.escape(\"Fo%^]N={*!BXG'NZQ\", charsetEncoder0, entities_EscapeMode0);"
    },
    {
        "focal_method": "    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                } // skip\n            } else {\n                String name = m.group(1).toLowerCase();\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n\n            if (charval != -1 || charval > 0xFFFF) { // out of range\n                String c = Character.toString((char) charval);\n                m.appendReplacement(accum, c);\n            } else {\n                m.appendReplacement(accum, m.group(0)); // replace with original string\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      String string0 = Entities.unescape(\"Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ\");\n      assertEquals(\"Fo%^]N={*!BXG'NZQ\", string0);\n}",
        "docstring": "",
        "id": "149",
        "project": "Jsoup",
        "bug_num": "4",
        "test_name": "org.jsoup.nodes.Entities_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ\", string0);",
        "prefix": "String string0 = Entities.unescape(\"Fo&percnt;&Hat;&rsqb;N&equals;&lcub;&midast;&excl;BXG&apos;NZQ\");"
    },
    {
        "focal_method": "    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0;\n    }",
        "test_prefix": "  public void test0()  throws Throwable  {\n      Whitelist whitelist0 = new Whitelist();\n      Cleaner cleaner0 = new Cleaner(whitelist0);\n      Document document0 = Document.createShell(\"org.jsoup.safeG Cleae$IlanrngVisitor\");\n      whitelist0.addEnforcedAttribute(\"body\", \"<html>\\n <head></head>\\n <body></body>\\n</html>\", \"org.jsoup.safeG Cleae$IlanrngVisitor\");\n      Document document1 = cleaner0.clean(document0);\n      boolean boolean0 = cleaner0.isValid(document1);\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n     Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n     in the input HTML are allowed by the whitelist.\n     <p/>\n     This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n     to ensure enforced attributes are set correctly, and that the output is tidied.\n     @param dirtyDocument document to test\n     @return true if no tags or attributes need to be removed; false if they do\n     */",
        "id": "150",
        "project": "Jsoup",
        "bug_num": "30",
        "test_name": "org.jsoup.safety.Cleaner_ESTest::test0",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Whitelist whitelist0 = new Whitelist();\n      Cleaner cleaner0 = new Cleaner(whitelist0);\n      Document document0 = Document.createShell(\"org.jsoup.safeG Cleae$IlanrngVisitor\");\n      whitelist0.addEnforcedAttribute(\"body\", \"<html>\\n <head></head>\\n <body></body>\\n</html>\", \"org.jsoup.safeG Cleae$IlanrngVisitor\");\n      Document document1 = cleaner0.clean(document0);\n      boolean boolean0 = cleaner0.isValid(document1);"
    },
    {
        "focal_method": "    static String escape(String string, Document.OutputSettings out) {\n        StringBuilder accum = new StringBuilder(string.length() * 2);\n        escape(accum, string, out, false, false, false);\n        return accum.toString();\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();\n      Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.xhtml;\n      document_OutputSettings0.escapeMode(entities_EscapeMode0);\n      StringBuilder stringBuilder0 = new StringBuilder();\n      Entities.escape(stringBuilder0, \"]?`?<DQr@*K\", document_OutputSettings0, true, true, true);\n      assertEquals(\"]?`?&lt;DQr@*K\", stringBuilder0.toString());\n}",
        "docstring": "",
        "id": "151",
        "project": "Jsoup",
        "bug_num": "47",
        "test_name": "org.jsoup.nodes.Entities_ESTest::test10",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"]?`?<DQr@*K\", stringBuilder0.toString());",
        "prefix": "Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();\n      Entities.EscapeMode entities_EscapeMode0 = Entities.EscapeMode.xhtml;\n      document_OutputSettings0.escapeMode(entities_EscapeMode0);\n      StringBuilder stringBuilder0 = new StringBuilder();\n      Entities.escape(stringBuilder0, \"]?`?<DQr@*K\", document_OutputSettings0, true, true, true);"
    },
    {
        "focal_method": "    public String nodeName() {\n        return \"#comment\";\n    }",
        "test_prefix": "  public void test6()  throws Throwable  {\n      Comment comment0 = new Comment(\"')GQz^]r=Tof\");\n      comment0.asXmlDeclaration();\n      assertEquals(\"#comment\", comment0.nodeName());\n}",
        "docstring": "",
        "id": "152",
        "project": "Jsoup",
        "bug_num": "86",
        "test_name": "org.jsoup.nodes.Comment_ESTest::test6",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"#comment\", comment0.nodeName());",
        "prefix": "Comment comment0 = new Comment(\"')GQz^]r=Tof\");\n      comment0.asXmlDeclaration();"
    },
    {
        "focal_method": "    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.childNodeSize() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }",
        "test_prefix": "  public void test6()  throws Throwable  {\n      Comment comment0 = new Comment(\"')GQz^]r=Tof\");\n      comment0.asXmlDeclaration();\n  }",
        "docstring": "/**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */",
        "id": "153",
        "project": "Jsoup",
        "bug_num": "86",
        "test_name": "org.jsoup.nodes.Comment_ESTest::test6",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"<'GQz^]r=Tof/>\", comment0.asXmlDeclaration());",
        "prefix": "Comment comment0 = new Comment(\"')GQz^]r=Tof\");\n      comment0.asXmlDeclaration();"
    },
    {
        "focal_method": "    public String getValue() {\n        return val;\n    }",
        "test_prefix": "  public void test04()  throws Throwable  {\n      Attribute attribute0 = new Attribute(\"\\\"s:O<.p~\\n~In\\\"ka,\", (String) null);\n      Attribute attribute1 = attribute0.clone();\n      boolean boolean0 = attribute1.equals(attribute0);\n      assertEquals(\"\", attribute1.getValue());\n}",
        "docstring": "/**\n     Get the attribute value.\n     @return the attribute value\n     */",
        "id": "154",
        "project": "Jsoup",
        "bug_num": "88",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test04",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\\\"s:O<.p~\", attribute1.getValue());",
        "prefix": "Attribute attribute0 = new Attribute(\"\\\"s:O<.p~\\n~In\\\"ka,\", (String) null);\n      Attribute attribute1 = attribute0.clone();\n      boolean boolean0 = attribute1.equals(attribute0);"
    },
    {
        "focal_method": "    public String getValue() {\n        return val;\n    }",
        "test_prefix": "  public void test20()  throws Throwable  {\n      Attribute attribute0 = new Attribute(\"\\\"s:O<.p~\\n~In\\\"ka,\", (String) null);\n      boolean boolean0 = attribute0.equals(attribute0);\n      assertEquals(\"\", attribute0.getValue());\n}",
        "docstring": "/**\n     Get the attribute value.\n     @return the attribute value\n     */",
        "id": "155",
        "project": "Jsoup",
        "bug_num": "88",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test20",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\\\"s:O<.p~\", attribute0.getValue());",
        "prefix": "Attribute attribute0 = new Attribute(\"\\\"s:O<.p~\\n~In\\\"ka,\", (String) null);\n      boolean boolean0 = attribute0.equals(attribute0);"
    },
    {
        "focal_method": "    public String getValue() {\n        return val;\n    }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      Attribute attribute0 = new Attribute(\"7b([!ve\", (String) null);\n      attribute0.hashCode();\n      assertEquals(\"\", attribute0.getValue());\n}",
        "docstring": "/**\n     Get the attribute value.\n     @return the attribute value\n     */",
        "id": "156",
        "project": "Jsoup",
        "bug_num": "88",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test25",
        "except_pred": "0",
        "assert_pred": "assertNull(attribute0.getValue());",
        "prefix": "Attribute attribute0 = new Attribute(\"7b([!ve\", (String) null);\n      attribute0.hashCode();"
    },
    {
        "focal_method": "",
        "test_prefix": "  public void test2()  throws Throwable  {\n      DataNode dataNode0 = new DataNode(\"trJ\");\n      Node[] nodeArray0 = dataNode0.childNodesAsArray();\n      assertEquals(0, nodeArray0.length);\n}",
        "docstring": "",
        "id": "157",
        "project": "Jsoup",
        "bug_num": "79",
        "test_name": "org.jsoup.nodes.LeafNode_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertNotNull(nodeArray0);",
        "prefix": "DataNode dataNode0 = new DataNode(\"trJ\");\n      Node[] nodeArray0 = dataNode0.childNodesAsArray();"
    },
    {
        "focal_method": "",
        "test_prefix": "  public void test2()  throws Throwable  {\n      DataNode dataNode0 = new DataNode(\"trJ\");\n      Node[] nodeArray0 = dataNode0.childNodesAsArray();\n  }",
        "docstring": "",
        "id": "158",
        "project": "Jsoup",
        "bug_num": "79",
        "test_name": "org.jsoup.nodes.LeafNode_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertNotNull(nodeArray0);",
        "prefix": "DataNode dataNode0 = new DataNode(\"trJ\");\n      Node[] nodeArray0 = dataNode0.childNodesAsArray();"
    },
    {
        "focal_method": "    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      Attribute attribute1 = attribute0.clone();\n      boolean boolean0 = attribute0.equals(attribute1);\n      assertEquals(\"\", attribute0.getValue());\n}",
        "docstring": "/**\n     Get the attribute value.\n     @return the attribute value\n     */",
        "id": "159",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"6xZW/$Zc\", attribute0.getValue());",
        "prefix": "Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      Attribute attribute1 = attribute0.clone();\n      boolean boolean0 = attribute0.equals(attribute1);"
    },
    {
        "focal_method": "    public boolean equals(Object o) { // note parent not considered\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Attribute attribute = (Attribute) o;\n        if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n        return val != null ? val.equals(attribute.val) : attribute.val == null;\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      Attribute attribute1 = attribute0.clone();\n      boolean boolean0 = attribute0.equals(attribute1);\n      assertTrue(boolean0);\n}",
        "docstring": "",
        "id": "160",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      Attribute attribute1 = attribute0.clone();\n      boolean boolean0 = attribute0.equals(attribute1);"
    },
    {
        "focal_method": "    public boolean equals(Object o) { // note parent not considered\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Attribute attribute = (Attribute) o;\n        if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n        return val != null ? val.equals(attribute.val) : attribute.val == null;\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      Attribute attribute1 = attribute0.clone();\n      boolean boolean0 = attribute0.equals(attribute1);\n  }",
        "docstring": "",
        "id": "161",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      Attribute attribute1 = attribute0.clone();\n      boolean boolean0 = attribute0.equals(attribute1);"
    },
    {
        "focal_method": "    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      attribute0.setValue((String) null);\n      boolean boolean0 = attribute0.isBooleanAttribute();\n      assertEquals(\"\", attribute0.getValue());\n}",
        "docstring": "/**\n     Get the attribute value.\n     @return the attribute value\n     */",
        "id": "162",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"9\", attribute0.getValue());",
        "prefix": "Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      attribute0.setValue((String) null);\n      boolean boolean0 = attribute0.isBooleanAttribute();"
    },
    {
        "focal_method": "    protected boolean isBooleanAttribute() {\n        return Arrays.binarySearch(booleanAttributes, key) >= 0 || val == null;\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      attribute0.setValue((String) null);\n      boolean boolean0 = attribute0.isBooleanAttribute();\n      assertTrue(boolean0);\n}",
        "docstring": "/**\n     * @deprecated\n     */",
        "id": "163",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      attribute0.setValue((String) null);\n      boolean boolean0 = attribute0.isBooleanAttribute();"
    },
    {
        "focal_method": "    protected boolean isBooleanAttribute() {\n        return Arrays.binarySearch(booleanAttributes, key) >= 0 || val == null;\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      attribute0.setValue((String) null);\n      boolean boolean0 = attribute0.isBooleanAttribute();\n  }",
        "docstring": "/**\n     * @deprecated\n     */",
        "id": "164",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      attribute0.setValue((String) null);\n      boolean boolean0 = attribute0.isBooleanAttribute();"
    },
    {
        "focal_method": "    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      Attribute attribute1 = attribute0.clone();\n      attribute1.setValue((String) null);\n      boolean boolean0 = attribute1.equals(attribute0);\n      assertEquals(\"\", attribute1.getValue());\n}",
        "docstring": "/**\n     Get the attribute value.\n     @return the attribute value\n     */",
        "id": "165",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test24",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"9\", attribute1.getValue());",
        "prefix": "Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      Attribute attribute1 = attribute0.clone();\n      attribute1.setValue((String) null);\n      boolean boolean0 = attribute1.equals(attribute0);"
    },
    {
        "focal_method": "    public boolean equals(Object o) { // note parent not considered\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Attribute attribute = (Attribute) o;\n        if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n        return val != null ? val.equals(attribute.val) : attribute.val == null;\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      Attribute attribute1 = attribute0.clone();\n      attribute1.setValue((String) null);\n      boolean boolean0 = attribute1.equals(attribute0);\n      assertFalse(boolean0);\n}",
        "docstring": "",
        "id": "166",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test24",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      Attribute attribute1 = attribute0.clone();\n      attribute1.setValue((String) null);\n      boolean boolean0 = attribute1.equals(attribute0);"
    },
    {
        "focal_method": "    public boolean equals(Object o) { // note parent not considered\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Attribute attribute = (Attribute) o;\n        if (key != null ? !key.equals(attribute.key) : attribute.key != null) return false;\n        return val != null ? val.equals(attribute.val) : attribute.val == null;\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      Attribute attribute1 = attribute0.clone();\n      attribute1.setValue((String) null);\n      boolean boolean0 = attribute1.equals(attribute0);\n  }",
        "docstring": "",
        "id": "167",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test24",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Attribute attribute0 = Attribute.createFromEncoded(\"9\", \"9\");\n      Attribute attribute1 = attribute0.clone();\n      attribute1.setValue((String) null);\n      boolean boolean0 = attribute1.equals(attribute0);"
    },
    {
        "focal_method": "    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }",
        "test_prefix": "  public void test26()  throws Throwable  {\n      Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      attribute0.hashCode();\n      assertEquals(\"\", attribute0.getValue());\n}",
        "docstring": "/**\n     Get the attribute value.\n     @return the attribute value\n     */",
        "id": "168",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test26",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"6xZW/$Zc\", attribute0.getValue());",
        "prefix": "Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      attribute0.hashCode();"
    },
    {
        "focal_method": "    public int hashCode() { // note parent not considered\n        int result = key != null ? key.hashCode() : 0;\n        result = 31 * result + (val != null ? val.hashCode() : 0);\n        return result;\n    }",
        "test_prefix": "  public void test26()  throws Throwable  {\n      Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      attribute0.hashCode();\n  }",
        "docstring": "",
        "id": "169",
        "project": "Jsoup",
        "bug_num": "89",
        "test_name": "org.jsoup.nodes.Attribute_ESTest::test26",
        "except_pred": "0",
        "assert_pred": "assertEquals((-1846230928), attribute0.hashCode());",
        "prefix": "Attribute attribute0 = new Attribute(\"6xZW/$Zc\", \"6xZW/$Zc\");\n      attribute0.setValue((String) null);\n      attribute0.hashCode();"
    },
    {
        "focal_method": "    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE\");\n        if (!StringUtil.isBlank(attr(\"name\")))\n            accum.append(\" \").append(attr(\"name\"));\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append('\"');\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append('\"');\n        accum.append('>');\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      StringBuilder stringBuilder0 = new StringBuilder();\n      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();\n      DocumentType documentType0 = new DocumentType(\"\", \"#doctype\", \"2oULXUb#K<| k8g\", \"\");\n      documentType0.outerHtmlHead(stringBuilder0, (-4119), document_OutputSettings0);\n      assertEquals(\"<!DOCTYPE PUBLIC \\\"#doctype\\\" \\\"2oULXUb#K<| k8g\\\">\", stringBuilder0.toString());\n}",
        "docstring": "",
        "id": "170",
        "project": "Jsoup",
        "bug_num": "40",
        "test_name": "org.jsoup.nodes.DocumentType_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"<!DOCTYPE2oULXUb#K<| k8g >\", stringBuilder0.toString());",
        "prefix": "StringBuilder stringBuilder0 = new StringBuilder();\n      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();\n      DocumentType documentType0 = new DocumentType(\"\", \"#doctype\", \"2oULXUb#K<| k8g\", \"\");\n      documentType0.outerHtmlHead(stringBuilder0, (-4119), document_OutputSettings0);"
    },
    {
        "focal_method": "    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE\");\n        if (!StringUtil.isBlank(attr(\"name\")))\n            accum.append(\" \").append(attr(\"name\"));\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append('\"');\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append('\"');\n        accum.append('>');\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      StringBuilder stringBuilder0 = new StringBuilder();\n      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();\n      DocumentType documentType0 = new DocumentType(\"\", \"#doctype\", \"2oULXUb#K<| k8g\", \"\");\n      documentType0.outerHtmlHead(stringBuilder0, (-4119), document_OutputSettings0);\n  }",
        "docstring": "",
        "id": "171",
        "project": "Jsoup",
        "bug_num": "40",
        "test_name": "org.jsoup.nodes.DocumentType_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"<!DOCTYPE2oULXUb#K<| k8g >\", stringBuilder0.toString());",
        "prefix": "StringBuilder stringBuilder0 = new StringBuilder();\n      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();\n      DocumentType documentType0 = new DocumentType(\"\", \"#doctype\", \"2oULXUb#K<| k8g\", \"\");\n      documentType0.outerHtmlHead(stringBuilder0, (-4119), document_OutputSettings0);"
    },
    {
        "focal_method": "    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n                if (Charset.isSupported(charset)) return charset;\n                charset = charset.toUpperCase(Locale.ENGLISH);\n                if (Charset.isSupported(charset)) return charset;\n                // if our advanced charset matching fails.... we just take the default\n        }\n        return null;\n    }",
        "test_prefix": "  public void test13()  throws Throwable  {\n      String string0 = DataUtil.getCharsetFromContentType(\"charset=\");\n      assertNull(string0);\n}",
        "docstring": "/**\n     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n     * will kick in.)\n     * @param contentType e.g. \"text/html; charset=EUC-JP\"\n     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n     */",
        "id": "172",
        "project": "Jsoup",
        "bug_num": "36",
        "test_name": "org.jsoup.helper.DataUtil_ESTest::test13",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"UTF-8\", string0);",
        "prefix": "String string0 = DataUtil.getCharsetFromContentType(\"charset=\");"
    },
    {
        "focal_method": "    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n                if (Charset.isSupported(charset)) return charset;\n                charset = charset.toUpperCase(Locale.ENGLISH);\n                if (Charset.isSupported(charset)) return charset;\n                // if our advanced charset matching fails.... we just take the default\n        }\n        return null;\n    }",
        "test_prefix": "  public void test13()  throws Throwable  {\n      String string0 = DataUtil.getCharsetFromContentType(\"charset=\");\n  }",
        "docstring": "/**\n     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n     * will kick in.)\n     * @param contentType e.g. \"text/html; charset=EUC-JP\"\n     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n     */",
        "id": "173",
        "project": "Jsoup",
        "bug_num": "36",
        "test_name": "org.jsoup.helper.DataUtil_ESTest::test13",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"UTF-8\", string0);",
        "prefix": "String string0 = DataUtil.getCharsetFromContentType(\"charset=\");"
    },
    {
        "focal_method": "    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Parser parser = new Parser(bodyHtml, baseUri, true);\n        return parser.parse();\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      Document document0 = Parser.parseBodyFragment(\"P%PBc.(\\\"(3d<f=dP@J\", \"P%PBc.(\\\"(3d<f=dP@J\");\n      assertEquals(\"#document\", document0.nodeName());\n}",
        "docstring": "/**\n     Parse a fragment of HTML into the {@code body} of a Document.\n     @param bodyHtml fragment of HTML\n     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     @return Document, with empty head, and HTML parsed into body\n     */",
        "id": "174",
        "project": "Jsoup",
        "bug_num": "5",
        "test_name": "org.jsoup.parser.Parser_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "assertNotNull(document0);",
        "prefix": "Document document0 = Parser.parseBodyFragment(\"P%PBc.(\\\"(3d<f=dP@J\", \"P%PBc.(\\\"(3d<f=dP@J\");"
    },
    {
        "focal_method": "    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Parser parser = new Parser(bodyHtml, baseUri, true);\n        return parser.parse();\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      Document document0 = Parser.parseBodyFragment(\"P%PBc.(\\\"(3d<f=dP@J\", \"P%PBc.(\\\"(3d<f=dP@J\");\n  }",
        "docstring": "/**\n     Parse a fragment of HTML into the {@code body} of a Document.\n     @param bodyHtml fragment of HTML\n     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     @return Document, with empty head, and HTML parsed into body\n     */",
        "id": "175",
        "project": "Jsoup",
        "bug_num": "5",
        "test_name": "org.jsoup.parser.Parser_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "assertNotNull(document0);",
        "prefix": "Document document0 = Parser.parseBodyFragment(\"P%PBc.(\\\"(3d<f=dP@J\", \"P%PBc.(\\\"(3d<f=dP@J\");"
    },
    {
        "focal_method": "    public String toString() {\n        return outerHtml();\n    }",
        "test_prefix": "  public void test08()  throws Throwable  {\n      DataNode dataNode0 = DataNode.createFromEncoded(\"Y3RuM2Iw}~sa=Np}\", \"\");\n      String string0 = dataNode0.toString();\n      assertEquals(\"Y3RuM2Iw}~sa=Np}\", string0);\n}",
        "docstring": "",
        "id": "176",
        "project": "Jsoup",
        "bug_num": "8",
        "test_name": "org.jsoup.nodes.Node_ESTest::test08",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"Y3RuM2Iw}~sa=Np}\", string0);",
        "prefix": "DataNode dataNode0 = DataNode.createFromEncoded(\"Y3RuM2Iw}~sa=Np}\", \"\");\n      String string0 = dataNode0.toString();"
    },
    {
        "focal_method": "    public String toString() {\n        return outerHtml();\n    }",
        "test_prefix": "  public void test08()  throws Throwable  {\n      DataNode dataNode0 = DataNode.createFromEncoded(\"Y3RuM2Iw}~sa=Np}\", \"\");\n      String string0 = dataNode0.toString();\n  }",
        "docstring": "",
        "id": "177",
        "project": "Jsoup",
        "bug_num": "8",
        "test_name": "org.jsoup.nodes.Node_ESTest::test08",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"Y3RuM2Iw}~sa=Np}\", string0);",
        "prefix": "DataNode dataNode0 = DataNode.createFromEncoded(\"Y3RuM2Iw}~sa=Np}\", \"\");\n      String string0 = dataNode0.toString();"
    },
    {
        "focal_method": "    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }",
        "test_prefix": "  public void test0()  throws Throwable  {\n      DocumentType documentType0 = new DocumentType(\"/:u'$8-DkwD}/:5\", \"/:u'$8-DkwD}/:5\", \"/:u'$8-DkwD}/:5\", \"/:u'$8-DkwD}/:5\");\n      String string0 = documentType0.outerHtml();\n      assertEquals(\"<!DOCTYPE /:u'$8-DkwD}/:5 PUBLIC \\\"/:u'$8-DkwD}/:5\\\" \\\"/:u'$8-DkwD}/:5\\\">\", string0);\n}",
        "docstring": "/**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */",
        "id": "178",
        "project": "Jsoup",
        "bug_num": "16",
        "test_name": "org.jsoup.nodes.DocumentType_ESTest::test0",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"/:u'$8-DkwD}/:5\", string0);",
        "prefix": "DocumentType documentType0 = new DocumentType(\"/:u'$8-DkwD}/:5\", \"/:u'$8-DkwD}/:5\", \"/:u'$8-DkwD}/:5\", \"/:u'$8-DkwD}/:5\");\n      String string0 = documentType0.outerHtml();"
    },
    {
        "focal_method": "    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE html\");\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(' ').append(attr(\"systemId\")).append(\"\\\"\");\n        accum.append('>');\n    }",
        "test_prefix": "  public void test1()  throws Throwable  {\n      DocumentType documentType0 = new DocumentType(\"ygL0pop.]WM:R$swY0g\", \"ygL0pop.]WM:R$swY0g\", \"ygL0pop.]WM:R$swY0g\", \"s)XlM.FRp.@;D$\");\n      Attributes attributes0 = new Attributes();\n      documentType0.attributes = attributes0;\n      StringBuilder stringBuilder0 = new StringBuilder();\n      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();\n      documentType0.outerHtmlHead(stringBuilder0, 1, document_OutputSettings0);\n      assertEquals(\"<!DOCTYPE >\", stringBuilder0.toString());\n}",
        "docstring": "",
        "id": "179",
        "project": "Jsoup",
        "bug_num": "16",
        "test_name": "org.jsoup.nodes.DocumentType_ESTest::test1",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "DocumentType documentType0 = new DocumentType(\"ygL0pop.]WM:R$swY0g\", \"ygL0pop.]WM:R$swY0g\", \"ygL0pop.]WM:R$swY0g\", \"s)XlM.FRp.@;D$\");\n      Attributes attributes0 = new Attributes();\n      documentType0.attributes = attributes0;\n      StringBuilder stringBuilder0 = new StringBuilder();\n      Document.OutputSettings document_OutputSettings0 = new Document.OutputSettings();\n      documentType0.outerHtmlHead(stringBuilder0, 1, document_OutputSettings0);"
    },
    {
        "focal_method": "    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if ((c.equals('\\'') || c.equals('\"')) && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        return out;\n    }",
        "test_prefix": "  public void test05()  throws Throwable  {\n      TokenQueue tokenQueue0 = new TokenQueue(\"'N7N;gmEL\");\n      // Undeclared exception!\n      try { \n        tokenQueue0.chompBalanced('\\'', '\\'');\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Did not find balanced maker at N7N;gmEL\n         //\n         verifyException(\"org.jsoup.helper.Validate\", e);\n      }\n  }",
        "docstring": "/**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */",
        "id": "180",
        "project": "Jsoup",
        "bug_num": "60",
        "test_name": "org.jsoup.parser.TokenQueue_ESTest::test05",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TokenQueue tokenQueue0 = new TokenQueue(\"'N7N;gmEL\");\n      // Undeclared exception!\n       \n        tokenQueue0.chompBalanced('\\'', '\\'');"
    },
    {
        "focal_method": "    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n            if (last == 0 || last != ESC) {\n                if ((c.equals('\\'') || c.equals('\"')) && c != open)\n                    inQuote = !inQuote;\n                if (inQuote)\n                    continue;\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c.equals(close))\n                    depth--;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        return out;\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      TokenQueue tokenQueue0 = new TokenQueue(\"heCIIhcb$o\");\n      // Undeclared exception!\n      try { \n        tokenQueue0.chompBalanced('h', 'h');\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Did not find balanced maker at eCIIhcb$o\n         //\n         verifyException(\"org.jsoup.helper.Validate\", e);\n      }\n  }",
        "docstring": "/**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */",
        "id": "181",
        "project": "Jsoup",
        "bug_num": "60",
        "test_name": "org.jsoup.parser.TokenQueue_ESTest::test24",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TokenQueue tokenQueue0 = new TokenQueue(\"heCIIhcb$o\");\n      // Undeclared exception!\n       \n        tokenQueue0.chompBalanced('h', 'h');"
    },
    {
        "focal_method": "    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return this == o;\n    }",
        "test_prefix": "  public void test69()  throws Throwable  {\n      Document document0 = new Document(\"value\");\n      Document document1 = new Document(\">5Z\");\n      boolean boolean0 = document0.equals(document1);\n      assertTrue(boolean0);\n}",
        "docstring": "",
        "id": "182",
        "project": "Jsoup",
        "bug_num": "41",
        "test_name": "org.jsoup.nodes.Element_ESTest::test69",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Document document0 = new Document(\"value\");\n      Document document1 = new Document(\">5Z\");\n      boolean boolean0 = document0.equals(document1);"
    },
    {
        "focal_method": "    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      CharacterReader characterReader0 = new CharacterReader(\"8Kr':%(6-\\\"p@8&Z_$8\");\n      boolean boolean0 = characterReader0.containsIgnoreCase(\"8Kr':%(6-\\\"p@8&Z_$8\");\n      assertFalse(boolean0);\n}",
        "docstring": "",
        "id": "183",
        "project": "Jsoup",
        "bug_num": "34",
        "test_name": "org.jsoup.parser.CharacterReader_ESTest::test12",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "CharacterReader characterReader0 = new CharacterReader(\"8Kr':%(6-\\\"p@8&Z_$8\");\n      boolean boolean0 = characterReader0.containsIgnoreCase(\"8Kr':%(6-\\\"p@8&Z_$8\");"
    },
    {
        "focal_method": "    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      CharacterReader characterReader0 = new CharacterReader(\"8Kr':%(6-\\\"p@8&Z_$8\");\n      boolean boolean0 = characterReader0.containsIgnoreCase(\"8Kr':%(6-\\\"p@8&Z_$8\");\n  }",
        "docstring": "",
        "id": "184",
        "project": "Jsoup",
        "bug_num": "34",
        "test_name": "org.jsoup.parser.CharacterReader_ESTest::test12",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "CharacterReader characterReader0 = new CharacterReader(\"8Kr':%(6-\\\"p@8&Z_$8\");\n      boolean boolean0 = characterReader0.containsIgnoreCase(\"8Kr':%(6-\\\"p@8&Z_$8\");"
    },
    {
        "focal_method": "    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }",
        "test_prefix": "  public void test0()  throws Throwable  {\n      Whitelist whitelist0 = Whitelist.basicWithImages();\n      Cleaner cleaner0 = new Cleaner(whitelist0);\n      Document document0 = new Document(\")}IYN&vF+R/bSRCs bc\");\n      Document document1 = cleaner0.clean(document0);\n      assertNotSame(document1, document0);\n}",
        "docstring": "/**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */",
        "id": "185",
        "project": "Jsoup",
        "bug_num": "26",
        "test_name": "org.jsoup.safety.Cleaner_ESTest::test0",
        "except_pred": "0",
        "assert_pred": "assertNotSame(document0, document1);",
        "prefix": "Whitelist whitelist0 = Whitelist.basicWithImages();\n      Cleaner cleaner0 = new Cleaner(whitelist0);\n      Document document0 = new Document(\")}IYN&vF+R/bSRCs bc\");\n      Document document1 = cleaner0.clean(document0);"
    },
    {
        "focal_method": "    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }",
        "test_prefix": "  public void test0()  throws Throwable  {\n      Whitelist whitelist0 = Whitelist.basicWithImages();\n      Cleaner cleaner0 = new Cleaner(whitelist0);\n      Document document0 = new Document(\")}IYN&vF+R/bSRCs bc\");\n      Document document1 = cleaner0.clean(document0);\n  }",
        "docstring": "/**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */",
        "id": "186",
        "project": "Jsoup",
        "bug_num": "26",
        "test_name": "org.jsoup.safety.Cleaner_ESTest::test0",
        "except_pred": "0",
        "assert_pred": "assertNotSame(document0, document1);",
        "prefix": "Whitelist whitelist0 = Whitelist.basicWithImages();\n      Cleaner cleaner0 = new Cleaner(whitelist0);\n      Document document0 = new Document(\")}IYN&vF+R/bSRCs bc\");\n      Document document1 = cleaner0.clean(document0);"
    },
    {
        "focal_method": "    boolean isSafeAttribute(String tagName, Element el, Attribute attr) {\n        TagName tag = TagName.valueOf(tagName);\n        AttributeKey key = AttributeKey.valueOf(attr.getKey());\n\n        if (attributes.containsKey(tag)) {\n            if (attributes.get(tag).contains(key)) {\n                if (protocols.containsKey(tag)) {\n                    Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\n                    // ok if not defined protocol; otherwise test\n                    return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\n                } else { // attribute found, no protocols defined, so OK\n                    return true;\n                }\n            }\n        } else { // no attributes defined for tag, try :all tag\n            return !tagName.equals(\":all\") && isSafeAttribute(\":all\", el, attr);\n        }\n        return false;\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      Whitelist whitelist0 = Whitelist.basicWithImages();\n      String[] stringArray0 = new String[3];\n      stringArray0[0] = \"cite\";\n      stringArray0[1] = \"h5WK''\";\n      stringArray0[2] = \"h5WK''\";\n      Whitelist whitelist1 = whitelist0.addAttributes(\"cite\", stringArray0);\n      Document document0 = new Document(\"h5WK''\");\n      Attribute attribute0 = Attribute.createFromEncoded(\"cite\", \"http:h5wk''\");\n      boolean boolean0 = whitelist1.isSafeAttribute(\"cite\", document0, attribute0);\n      assertTrue(boolean0);\n}",
        "docstring": "",
        "id": "187",
        "project": "Jsoup",
        "bug_num": "19",
        "test_name": "org.jsoup.safety.Whitelist_ESTest::test10",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "Whitelist whitelist0 = Whitelist.basicWithImages();\n      String[] stringArray0 = new String[3];\n      stringArray0[0] = \"cite\";\n      stringArray0[1] = \"h5WK''\";\n      stringArray0[2] = \"h5WK''\";\n      Whitelist whitelist1 = whitelist0.addAttributes(\"cite\", stringArray0);\n      Document document0 = new Document(\"h5WK''\");\n      Attribute attribute0 = Attribute.createFromEncoded(\"cite\", \"http:h5wk''\");\n      boolean boolean0 = whitelist1.isSafeAttribute(\"cite\", document0, attribute0);"
    },
    {
        "focal_method": "    public int pos() {\n        return readerPos + bufPos;\n    }",
        "test_prefix": "  public void test31()  throws Throwable  {\n      CharacterReader characterReader0 = new CharacterReader(\"<A)s.2T#T`V\");\n      String string0 = characterReader0.consumeTagName();\n      assertEquals(0, characterReader0.pos());\n}",
        "docstring": "/**\n     * Gets the current cursor position in the content.\n     * @return current position\n     */",
        "id": "188",
        "project": "Jsoup",
        "bug_num": "83",
        "test_name": "org.jsoup.parser.CharacterReader_ESTest::test31",
        "except_pred": "0",
        "assert_pred": "assertEquals(1, characterReader0.pos());",
        "prefix": "CharacterReader characterReader0 = new CharacterReader(\"<A)s.2T#T`V\");\n      String string0 = characterReader0.consumeTagName();"
    },
    {
        "focal_method": "    public String toString() {\n        return input.substring(pos);\n    }",
        "test_prefix": "  public void test14()  throws Throwable  {\n      CharacterReader characterReader0 = new CharacterReader(\"J\");\n      boolean boolean0 = characterReader0.matchConsumeIgnoreCase(\"J\");\n      characterReader0.consumeTo('J');\n      assertEquals(\"\", characterReader0.toString());\n}",
        "docstring": "",
        "id": "189",
        "project": "Jsoup",
        "bug_num": "18",
        "test_name": "org.jsoup.parser.CharacterReader_ESTest::test14",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"J\", characterReader0.toString());",
        "prefix": "CharacterReader characterReader0 = new CharacterReader(\"J\");\n      boolean boolean0 = characterReader0.matchConsumeIgnoreCase(\"J\");\n      characterReader0.consumeTo('J');"
    },
    {
        "focal_method": "    String consumeTo(char c) {\n        int offset = input.indexOf(c, pos);\n        if (offset != -1) {\n            String consumed = input.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }",
        "test_prefix": "  public void test14()  throws Throwable  {\n      CharacterReader characterReader0 = new CharacterReader(\"J\");\n      boolean boolean0 = characterReader0.matchConsumeIgnoreCase(\"J\");\n      characterReader0.consumeTo('J');\n  }",
        "docstring": "",
        "id": "190",
        "project": "Jsoup",
        "bug_num": "18",
        "test_name": "org.jsoup.parser.CharacterReader_ESTest::test14",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"J\", characterReader0.consumeTo());",
        "prefix": "CharacterReader characterReader0 = new CharacterReader(\"J\");\n      boolean boolean0 = characterReader0.matchConsumeIgnoreCase(\"J\");\n      characterReader0.consumeTo('J');"
    },
    {
        "focal_method": "    private Token() {\n    }",
        "test_prefix": "  public void test33()  throws Throwable  {\n      Token.EndTag token_EndTag0 = new Token.EndTag();\n      token_EndTag0.appendAttributeName(\"\");\n      token_EndTag0.newAttribute();\n  }",
        "docstring": "",
        "id": "191",
        "project": "Jsoup",
        "bug_num": "59",
        "test_name": "org.jsoup.parser.Token_ESTest::test33",
        "except_pred": "0",
        "assert_pred": "assertEquals(6, token_EndTag0.doEndTag());",
        "prefix": "Token.EndTag token_EndTag0 = new Token.EndTag();\n      token_EndTag0.appendAttributeName(\"\");\n      token_EndTag0.newAttribute();"
    },
    {
        "focal_method": "    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      byte[] byteArray0 = new byte[4];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte)1, (byte)1);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, (byte)1, 2);\n      assertArrayEquals(new byte[] {(byte)48, (byte)32, (byte)0, (byte)0}, byteArray0);\n}",
        "docstring": "/** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */",
        "id": "192",
        "project": "Compress",
        "bug_num": "27",
        "test_name": "org.apache.commons.compress.archivers.tar.TarUtils_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "assertEquals(0L, long0);",
        "prefix": "byte[] byteArray0 = new byte[4];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte)1, (byte)1);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, (byte)1, 2);"
    },
    {
        "focal_method": "    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      byte[] byteArray0 = new byte[4];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte)1, (byte)1);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, (byte)1, 2);\n      assertEquals(0L, long0);\n}",
        "docstring": "/** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */",
        "id": "193",
        "project": "Compress",
        "bug_num": "27",
        "test_name": "org.apache.commons.compress.archivers.tar.TarUtils_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "assertEquals(0L, long0);",
        "prefix": "byte[] byteArray0 = new byte[4];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte)1, (byte)1);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, (byte)1, 2);"
    },
    {
        "focal_method": "    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      byte[] byteArray0 = new byte[4];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte)1, (byte)1);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, (byte)1, 2);\n  }",
        "docstring": "/** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */",
        "id": "194",
        "project": "Compress",
        "bug_num": "27",
        "test_name": "org.apache.commons.compress.archivers.tar.TarUtils_ESTest::test00",
        "except_pred": "0",
        "assert_pred": "assertEquals(0L, long0);",
        "prefix": "byte[] byteArray0 = new byte[4];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(0L, byteArray0, (byte)1, (byte)1);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, (byte)1, 2);"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test22()  throws Throwable  {\n      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);\n      zipArchiveOutputStream0.close();\n      assertEquals(0, byteArrayOutputStream0.size());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "195",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test22",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertTrue(mockFile0.exists());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "196",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(\"bad CRC checksum for entry \", mockFile0.toString());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "197",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertFalse(mockFile0.isDirectory());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "198",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(0L, mockFile0.getFreeSpace());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "199",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertNull(mockFile0.getParent());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "200",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertFalse(mockFile0.isHidden());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "201",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(0L, mockFile0.getUsableSpace());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "202",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertTrue(mockFile0.canExecute());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "203",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(\"bad CRC checksum for entry \", mockFile0.getName());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "204",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertTrue(mockFile0.canRead());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "205",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertTrue(mockFile0.canWrite());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "206",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertTrue(mockFile0.isFile());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "207",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(0L, mockFile0.getTotalSpace());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "208",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(1392409281320L, mockFile0.lastModified());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "209",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(0L, mockFile0.length());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "210",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertFalse(mockFile0.isAbsolute());\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "211",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public boolean isSeekable() {\n        return raf != null;\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertTrue(zipArchiveOutputStream0.isSeekable());\n}",
        "docstring": "/**\n     * This method indicates whether this archive is writing to a\n     * seekable stream (i.e., to a random access file).\n     *\n     * <p>For seekable streams, you don't need to calculate the CRC or\n     * uncompressed size for {@link #STORED} entries before\n     * invoking {@link #putArchiveEntry(ArchiveEntry)}.\n     * @return true if seekable\n     */",
        "id": "212",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.isSeekable());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public String getEncoding() {\n        return encoding;\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(\"UTF8\", zipArchiveOutputStream0.getEncoding());\n}",
        "docstring": "/**\n     * The encoding to use for filenames and the file comment.\n     *\n     * @return null if using the platform's default character encoding.\n     */",
        "id": "213",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"UTF-8\", zipArchiveOutputStream0.getEncoding());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(2048, ZipArchiveOutputStream.EFS_FLAG);\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "214",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(0, ZipArchiveOutputStream.STORED);\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "215",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals((-1), ZipArchiveOutputStream.DEFAULT_COMPRESSION);\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "216",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n      assertEquals(8, ZipArchiveOutputStream.DEFLATED);\n}",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "217",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();\n  }",
        "docstring": "/**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */",
        "id": "218",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.archiveHasBeenExtracted());",
        "prefix": "MockFile mockFile0 = new MockFile(\"bad CRC checksum for entry \");\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(mockFile0);\n      zipArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            out.close();\n            this.closed = true;\n        }\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);\n      cpioArchiveOutputStream0.close();\n      assertEquals(0, byteArrayOutputStream0.size());\n}",
        "docstring": "/**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */",
        "id": "219",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream_ESTest::test10",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, byteArrayOutputStream0.size());",
        "prefix": "ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);\n      cpioArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which hasn't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        return results;\n    }",
        "test_prefix": "  public void test0()  throws Throwable  {\n      ChangeSet changeSet0 = new ChangeSet();\n      JarArchiveOutputStream jarArchiveOutputStream0 = new JarArchiveOutputStream((OutputStream) null);\n      byte[] byteArray0 = new byte[9];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)0, 190);\n      changeSet0.deleteDir(\"\");\n      ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0, \"m\", false);\n      ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);\n      // Undeclared exception!\n      try { \n        changeSetPerformer0.perform(zipArchiveInputStream0, jarArchiveOutputStream0);\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n         //\n         // no message in exception (getMessage() returned null)\n         //\n         verifyException(\"org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream\", e);\n      }\n  }",
        "docstring": "/**\n     * Performs all changes collected in this ChangeSet on the input stream and\n     * streams the result to the output stream. Perform may be called more than once.\n     * \n     * This method finishes the stream, no other entries should be added\n     * after that.\n     * \n     * @param in\n     *            the InputStream to perform the changes on\n     * @param out\n     *            the resulting OutputStream with all modifications\n     * @throws IOException\n     *             if an read/write error occurs\n     * @return the results of this operation\n     */",
        "id": "220",
        "project": "Compress",
        "bug_num": "4",
        "test_name": "org.apache.commons.compress.changes.ChangeSetPerformer_ESTest::test0",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "ChangeSet changeSet0 = new ChangeSet();\n      JarArchiveOutputStream jarArchiveOutputStream0 = new JarArchiveOutputStream((OutputStream) null);\n      byte[] byteArray0 = new byte[9];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)0, 190);\n      changeSet0.deleteDir(\"\");\n      ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0, \"m\", false);\n      ChangeSetPerformer changeSetPerformer0 = new ChangeSetPerformer(changeSet0);\n      // Undeclared exception!\n       \n        changeSetPerformer0.perform(zipArchiveInputStream0, jarArchiveOutputStream0);"
    },
    {
        "focal_method": "    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\n        this.checksum = checksum;\n        this.in = in;\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      FileDescriptor fileDescriptor0 = new FileDescriptor();\n      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);\n      ChecksumCalculatingInputStream checksumCalculatingInputStream0 = null;\n      try {\n        checksumCalculatingInputStream0 = new ChecksumCalculatingInputStream((Checksum) null, mockFileInputStream0);\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n         //\n         // Parameter checksum must not be null\n         //\n         verifyException(\"org.apache.commons.compress.utils.ChecksumCalculatingInputStream\", e);\n      }\n  }",
        "docstring": "",
        "id": "221",
        "project": "Compress",
        "bug_num": "44",
        "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream_ESTest::test2",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "FileDescriptor fileDescriptor0 = new FileDescriptor();\n      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);\n      ChecksumCalculatingInputStream checksumCalculatingInputStream0 = null;\n      \n        checksumCalculatingInputStream0 = new ChecksumCalculatingInputStream((Checksum) null, mockFileInputStream0);"
    },
    {
        "focal_method": "    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n\n\n\n        this.checksum = checksum;\n        this.in = in;\n    }",
        "test_prefix": "  public void test3()  throws Throwable  {\n      Adler32 adler32_0 = new Adler32();\n      ChecksumCalculatingInputStream checksumCalculatingInputStream0 = null;\n      try {\n        checksumCalculatingInputStream0 = new ChecksumCalculatingInputStream(adler32_0, (InputStream) null);\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n         //\n         // Parameter in must not be null\n         //\n         verifyException(\"org.apache.commons.compress.utils.ChecksumCalculatingInputStream\", e);\n      }\n  }",
        "docstring": "",
        "id": "222",
        "project": "Compress",
        "bug_num": "44",
        "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream_ESTest::test3",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "Adler32 adler32_0 = new Adler32();\n      ChecksumCalculatingInputStream checksumCalculatingInputStream0 = null;\n      \n        checksumCalculatingInputStream0 = new ChecksumCalculatingInputStream(adler32_0, (InputStream) null);"
    },
    {
        "focal_method": "    public void setModifyJavaTime(final Date d) { setModifyTime(dateToZipLong(d)); }",
        "test_prefix": "  public void test27()  throws Throwable  {\n      X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();\n      MockDate mockDate0 = new MockDate((-2), (byte)2, (byte)2);\n      // Undeclared exception!\n      try { \n        x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // X5455 timestamps must fit in a signed 32 bit integer: -2266876800\n         //\n         verifyException(\"org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>\n     * Sets the modify time as a java.util.Date\n     * of this zip entry.  Supplied value is truncated to per-second\n     * precision (milliseconds zeroed-out).\n     * </p><p>\n     * Note: the setters for flags and timestamps are decoupled.\n     * Even if the timestamp is not-null, it will only be written\n     * out if the corresponding bit in the flags is also set.\n     * </p>\n     *\n     * @param d modify time as java.util.Date\n     */",
        "id": "223",
        "project": "Compress",
        "bug_num": "46",
        "test_name": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp_ESTest::test27",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "X5455_ExtendedTimestamp x5455_ExtendedTimestamp0 = new X5455_ExtendedTimestamp();\n      MockDate mockDate0 = new MockDate((-2), (byte)2, (byte)2);\n      // Undeclared exception!\n       \n        x5455_ExtendedTimestamp0.setModifyJavaTime(mockDate0);"
    },
    {
        "focal_method": "    public ArchiveOutputStream createArchiveOutputStream(\n            final String archiverName, final OutputStream out)\n            throws ArchiveException {\n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        if (out == null) {\n            throw new IllegalArgumentException(\"OutputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveOutputStream(out);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n            if (entryEncoding != null) {\n                zip.setEncoding(entryEncoding);\n            }\n            return zip;\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new TarArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new TarArchiveOutputStream(out);\n            }\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n                return new JarArchiveOutputStream(out);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveOutputStream(out, entryEncoding);\n            } else {\n                return new CpioArchiveOutputStream(out);\n            }\n        }\n        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }",
        "test_prefix": "  public void test28()  throws Throwable  {\n      ArchiveStreamFactory archiveStreamFactory0 = new ArchiveStreamFactory(\"\");\n      MockPrintStream mockPrintStream0 = new MockPrintStream(\"arj\");\n      // Undeclared exception!\n      try { \n        archiveStreamFactory0.createArchiveOutputStream(\"jar\", mockPrintStream0);\n        fail(\"Expecting exception: IllegalCharsetNameException\");\n      } catch(IllegalCharsetNameException e) {\n         //\n         // \n         //\n         verifyException(\"java.nio.charset.Charset\", e);\n      }\n  }",
        "docstring": "/**\n     * Create an archive output stream from an archiver name and an output stream.\n     * \n     * @param archiverName the archive name,\n     * i.e. {@value #AR}, {@value #ZIP}, {@value #TAR}, {@value #JAR} or {@value #CPIO} \n     * @param out the output stream\n     * @return the archive output stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws StreamingNotSupportedException if the format cannot be\n     * written to a stream\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */",
        "id": "224",
        "project": "Compress",
        "bug_num": "29",
        "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactory_ESTest::test28",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "ArchiveStreamFactory archiveStreamFactory0 = new ArchiveStreamFactory(\"\");\n      MockPrintStream mockPrintStream0 = new MockPrintStream(\"arj\");\n      // Undeclared exception!\n       \n        archiveStreamFactory0.createArchiveOutputStream(\"jar\", mockPrintStream0);"
    },
    {
        "focal_method": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        byte trailer = buffer[end - 1];\n        if (trailer == 0 || trailer == ' '){\n            end--;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end-1, trailer));\n        }\n        trailer = buffer[end - 1];\n        while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n            end--;\n            trailer = buffer[end - 1];\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      byte[] byteArray0 = new byte[4];\n      byteArray0[2] = (byte)32;\n      byteArray0[3] = (byte)32;\n      // Undeclared exception!\n      try { \n        TarUtils.parseOctal(byteArray0, 2, 2);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Invalid byte 32 at offset 2 in '  ' len=2\n         //\n         verifyException(\"org.apache.commons.compress.archivers.tar.TarUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */",
        "id": "225",
        "project": "Compress",
        "bug_num": "24",
        "test_name": "org.apache.commons.compress.archivers.tar.TarUtils_ESTest::test10",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[4];\n      byteArray0[2] = (byte)32;\n      byteArray0[3] = (byte)32;\n      // Undeclared exception!\n       \n        TarUtils.parseOctal(byteArray0, 2, 2);"
    },
    {
        "focal_method": "    public long getBytesWritten() {\n        return bytesWritten;\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      File file0 = MockFile.createTempFile(\"Ou{e 6;.kh\", \"Ou{e 6;.kh\");\n      MockPrintStream mockPrintStream0 = new MockPrintStream(file0);\n      TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(mockPrintStream0);\n      tarArchiveOutputStream0.close();\n      tarArchiveOutputStream0.close();\n      assertEquals(10240L, tarArchiveOutputStream0.getBytesWritten());\n}",
        "docstring": "/**\n     * Returns the current number of bytes written to this stream.\n     * @return the number of written bytes\n     * @since Apache Commons Compress 1.1\n     */",
        "id": "226",
        "project": "Compress",
        "bug_num": "9",
        "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertEquals(0L, tarArchiveOutputStream0.getBytesWritten());",
        "prefix": "File file0 = MockFile.createTempFile(\"Ou{e 6;.kh\", \"Ou{e 6;.kh\");\n      MockPrintStream mockPrintStream0 = new MockPrintStream(file0);\n      TarArchiveOutputStream tarArchiveOutputStream0 = new TarArchiveOutputStream(mockPrintStream0);\n      tarArchiveOutputStream0.close();\n      tarArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public ArchiveInputStream createArchiveInputStream(\n            final String archiverName, final InputStream in)\n            throws ArchiveException {\n        \n        if (archiverName == null) {\n            throw new IllegalArgumentException(\"Archivername must not be null.\");\n        }\n        \n        if (in == null) {\n            throw new IllegalArgumentException(\"InputStream must not be null.\");\n        }\n\n        if (AR.equalsIgnoreCase(archiverName)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (ZIP.equalsIgnoreCase(archiverName)) {\n            return new ZipArchiveInputStream(in);\n        }\n        if (TAR.equalsIgnoreCase(archiverName)) {\n            return new TarArchiveInputStream(in);\n        }\n        if (JAR.equalsIgnoreCase(archiverName)) {\n            return new JarArchiveInputStream(in);\n        }\n        if (CPIO.equalsIgnoreCase(archiverName)) {\n            return new CpioArchiveInputStream(in);\n        }\n        if (DUMP.equalsIgnoreCase(archiverName)) {\n            return new DumpArchiveInputStream(in);\n        }\n        \n        throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n    }",
        "test_prefix": "  public void test16()  throws Throwable  {\n      byte[] byteArray0 = new byte[179];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);\n      ArchiveStreamFactory archiveStreamFactory0 = new ArchiveStreamFactory();\n      try { \n        archiveStreamFactory0.createArchiveInputStream((InputStream) byteArrayInputStream0);\n        fail(\"Expecting exception: Exception\");\n      } catch(Exception e) {\n         //\n         // No Archiver found for the stream signature\n         //\n         verifyException(\"org.apache.commons.compress.archivers.ArchiveStreamFactory\", e);\n      }\n  }",
        "docstring": "/**\n     * Create an archive input stream from an archiver name and an input stream.\n     * \n     * @param archiverName the archive name, i.e. \"ar\", \"zip\", \"tar\", \"jar\", \"dump\" or \"cpio\"\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known\n     * @throws IllegalArgumentException if the archiver name or stream is null\n     */",
        "id": "227",
        "project": "Compress",
        "bug_num": "11",
        "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactory_ESTest::test16",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[179];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);\n      ArchiveStreamFactory archiveStreamFactory0 = new ArchiveStreamFactory();\n       \n        archiveStreamFactory0.createArchiveInputStream((InputStream) byteArrayInputStream0);"
    },
    {
        "focal_method": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n        int     start = offset;\n\n        for (int i = start; i < end; i++){\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) {\n                break;\n            }\n\n        // Skip leading spaces\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                   continue;\n            }\n                if (currentByte == (byte) ' ') {\n                break;\n                }\n            }\n\n        // Must have trailing NUL or space\n        // May have additional NUL or space\n\n            stillPadding = false;\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
        "test_prefix": "  public void test02()  throws Throwable  {\n      byte[] byteArray0 = new byte[25];\n      byteArray0[4] = (byte)54;\n      // Undeclared exception!\n      try { \n        TarUtils.parseOctal(byteArray0, (byte)3, 2);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Invalid byte 54 at offset 1 in '{NUL}6' len=2\n         //\n         verifyException(\"org.apache.commons.compress.archivers.tar.TarUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */",
        "id": "228",
        "project": "Compress",
        "bug_num": "8",
        "test_name": "org.apache.commons.compress.archivers.tar.TarUtils_ESTest::test02",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[25];\n      byteArray0[4] = (byte)54;\n      // Undeclared exception!\n       \n        TarUtils.parseOctal(byteArray0, (byte)3, 2);"
    },
    {
        "focal_method": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        boolean stillPadding = true;\n        int     end = offset + length;\n        int     start = offset;\n\n        for (int i = start; i < end; i++){\n            final byte currentByte = buffer[i];\n            if (currentByte == 0) {\n                break;\n            }\n\n        // Skip leading spaces\n            if (currentByte == (byte) ' ' || currentByte == '0') {\n                if (stillPadding) {\n                   continue;\n            }\n                if (currentByte == (byte) ' ') {\n                break;\n                }\n            }\n\n        // Must have trailing NUL or space\n        // May have additional NUL or space\n\n            stillPadding = false;\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }",
        "test_prefix": "  public void test04()  throws Throwable  {\n      byte[] byteArray0 = new byte[9];\n      // Undeclared exception!\n      try { \n        TarUtils.parseOctal(byteArray0, (byte)3, (byte)0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Length 0 must be at least 2\n         //\n         verifyException(\"org.apache.commons.compress.archivers.tar.TarUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */",
        "id": "229",
        "project": "Compress",
        "bug_num": "8",
        "test_name": "org.apache.commons.compress.archivers.tar.TarUtils_ESTest::test04",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[9];\n      // Undeclared exception!\n       \n        TarUtils.parseOctal(byteArray0, (byte)3, (byte)0);"
    },
    {
        "focal_method": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n        }\n        \n        entriesRead++;\n        return current.entry;\n    }",
        "test_prefix": "  public void test03()  throws Throwable  {\n      byte[] byteArray0 = new byte[40];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);\n      ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);\n      try { \n        zipArchiveInputStream0.getNextZipEntry();\n        fail(\"Expecting exception: ZipException\");\n      } catch(ZipException e) {\n         //\n         // Unexpected record signature: 0X0\n         //\n         verifyException(\"org.apache.commons.compress.archivers.zip.ZipArchiveInputStream\", e);\n      }\n  }",
        "docstring": "",
        "id": "230",
        "project": "Compress",
        "bug_num": "41",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream_ESTest::test03",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[40];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);\n      ZipArchiveInputStream zipArchiveInputStream0 = new ZipArchiveInputStream(byteArrayInputStream0);\n       \n        zipArchiveInputStream0.getNextZipEntry();"
    },
    {
        "focal_method": "    public ZipShort getCentralDirectoryLength() {\n        return getLocalFileDataLength();\n    }",
        "test_prefix": "  public void test04()  throws Throwable  {\n      X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();\n      ZipShort zipShort0 = x7875_NewUnix0.getCentralDirectoryLength();\n      assertEquals(0, zipShort0.getValue());\n}",
        "docstring": "/**\n     * Length of the extra field in the central directory data - without\n     * Header-ID or length specifier.\n     *\n     * @return a <code>ZipShort</code> for the length of the data of this extra field\n     */",
        "id": "231",
        "project": "Compress",
        "bug_num": "34",
        "test_name": "org.apache.commons.compress.archivers.zip.X7875_NewUnix_ESTest::test04",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, zipShort0.getValue());",
        "prefix": "X7875_NewUnix x7875_NewUnix0 = new X7875_NewUnix();\n      ZipShort zipShort0 = x7875_NewUnix0.getCentralDirectoryLength();"
    },
    {
        "focal_method": "    public ArArchiveEntry getNextArEntry() throws IOException {\n                    // hit EOF before previous entry was complete\n                    // TODO: throw an exception instead?\n\n        if (offset == 0) {\n            final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n            final byte[] realized = new byte[expected.length]; \n            final int read = read(realized);\n            if (read != expected.length) {\n                throw new IOException(\"failed to read header\");\n            }\n            for (int i = 0; i < expected.length; i++) {\n                if (expected[i] != realized[i]) {\n                    throw new IOException(\"invalid header \" + new String(realized));\n                }\n            }\n        }\n\n                // hit eof\n\n        if (input.available() == 0) {\n            return null;\n        }\n\n        if (offset % 2 != 0) {\n            read();\n        }\n        final byte[] name = new byte[16];\n        final byte[] lastmodified = new byte[12];\n        final byte[] userid = new byte[6];\n        final byte[] groupid = new byte[6];\n        final byte[] filemode = new byte[8];\n        final byte[] length = new byte[10];\n\n        read(name);\n        read(lastmodified);\n        read(userid);\n        read(groupid);\n        read(filemode);\n        read(length);\n\n        {\n            final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\n            final byte[] realized = new byte[expected.length]; \n            final int read = read(realized);\n            if (read != expected.length) {\n                throw new IOException(\"failed to read entry header\");\n            }\n            for (int i = 0; i < expected.length; i++) {\n                if (expected[i] != realized[i]) {\n                    throw new IOException(\"invalid entry header. not read the content?\");\n                }\n            }\n        }\n\n        return new ArArchiveEntry(new String(name).trim(),\n                                          Long.parseLong(new String(length)\n                                                         .trim()));\n    }",
        "test_prefix": "  public void test04()  throws Throwable  {\n      byte[] byteArray0 = new byte[2];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte)1);\n      ArArchiveInputStream arArchiveInputStream0 = new ArArchiveInputStream(byteArrayInputStream0);\n      arArchiveInputStream0.read();\n      ArArchiveEntry arArchiveEntry0 = arArchiveInputStream0.getNextArEntry();\n      assertNull(arArchiveEntry0);\n}",
        "docstring": "/**\n     * Returns the next AR entry in this stream.\n     * \n     * @return the next AR entry.\n     * @throws IOException\n     *             if the entry could not be read\n     */",
        "id": "232",
        "project": "Compress",
        "bug_num": "2",
        "test_name": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream_ESTest::test04",
        "except_pred": "0",
        "assert_pred": "assertNull(arArchiveEntry0);",
        "prefix": "byte[] byteArray0 = new byte[2];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte)1);\n      ArArchiveInputStream arArchiveInputStream0 = new ArArchiveInputStream(byteArrayInputStream0);\n      arArchiveInputStream0.read();\n      ArArchiveEntry arArchiveEntry0 = arArchiveInputStream0.getNextArEntry();"
    },
    {
        "focal_method": "    public ArArchiveEntry getNextArEntry() throws IOException {\n                    // hit EOF before previous entry was complete\n                    // TODO: throw an exception instead?\n\n        if (offset == 0) {\n            final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n            final byte[] realized = new byte[expected.length]; \n            final int read = read(realized);\n            if (read != expected.length) {\n                throw new IOException(\"failed to read header\");\n            }\n            for (int i = 0; i < expected.length; i++) {\n                if (expected[i] != realized[i]) {\n                    throw new IOException(\"invalid header \" + new String(realized));\n                }\n            }\n        }\n\n                // hit eof\n\n        if (input.available() == 0) {\n            return null;\n        }\n\n        if (offset % 2 != 0) {\n            read();\n        }\n        final byte[] name = new byte[16];\n        final byte[] lastmodified = new byte[12];\n        final byte[] userid = new byte[6];\n        final byte[] groupid = new byte[6];\n        final byte[] filemode = new byte[8];\n        final byte[] length = new byte[10];\n\n        read(name);\n        read(lastmodified);\n        read(userid);\n        read(groupid);\n        read(filemode);\n        read(length);\n\n        {\n            final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\n            final byte[] realized = new byte[expected.length]; \n            final int read = read(realized);\n            if (read != expected.length) {\n                throw new IOException(\"failed to read entry header\");\n            }\n            for (int i = 0; i < expected.length; i++) {\n                if (expected[i] != realized[i]) {\n                    throw new IOException(\"invalid entry header. not read the content?\");\n                }\n            }\n        }\n\n        return new ArArchiveEntry(new String(name).trim(),\n                                          Long.parseLong(new String(length)\n                                                         .trim()));\n    }",
        "test_prefix": "  public void test04()  throws Throwable  {\n      byte[] byteArray0 = new byte[2];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte)1);\n      ArArchiveInputStream arArchiveInputStream0 = new ArArchiveInputStream(byteArrayInputStream0);\n      arArchiveInputStream0.read();\n      ArArchiveEntry arArchiveEntry0 = arArchiveInputStream0.getNextArEntry();\n  }",
        "docstring": "/**\n     * Returns the next AR entry in this stream.\n     * \n     * @return the next AR entry.\n     * @throws IOException\n     *             if the entry could not be read\n     */",
        "id": "233",
        "project": "Compress",
        "bug_num": "2",
        "test_name": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream_ESTest::test04",
        "except_pred": "0",
        "assert_pred": "assertNull(arArchiveEntry0);",
        "prefix": "byte[] byteArray0 = new byte[2];\n      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, (byte)1, (byte)1);\n      ArArchiveInputStream arArchiveInputStream0 = new ArArchiveInputStream(byteArrayInputStream0);\n      arArchiveInputStream0.read();\n      ArArchiveEntry arArchiveEntry0 = arArchiveInputStream0.getNextArEntry();"
    },
    {
        "focal_method": "",
        "test_prefix": "  public void test10()  throws Throwable  {\n      byte[] byteArray0 = new byte[6];\n      byteArray0[4] = (byte) (-35);\n      Coders.LZMADecoder coders_LZMADecoder0 = new Coders.LZMADecoder();\n      PipedInputStream pipedInputStream0 = new PipedInputStream(1);\n      BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pipedInputStream0, (byte)119);\n      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(bufferedInputStream0, pipedInputStream0);\n      Coder coder0 = new Coder();\n      coder0.properties = byteArray0;\n      try { \n        coders_LZMADecoder0.decode(sequenceInputStream0, coder0, byteArray0);\n        fail(\"Expecting exception: IOException\");\n      } catch(IOException e) {\n         //\n         // Dictionary larger than 4GiB maximum size\n         //\n         verifyException(\"org.apache.commons.compress.archivers.sevenz.Coders$LZMADecoder\", e);\n      }\n  }",
        "docstring": "",
        "id": "234",
        "project": "Compress",
        "bug_num": "23",
        "test_name": "org.apache.commons.compress.archivers.sevenz.Coders_ESTest::test10",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "byte[] byteArray0 = new byte[6];\n      byteArray0[4] = (byte) (-35);\n      Coders.LZMADecoder coders_LZMADecoder0 = new Coders.LZMADecoder();\n      PipedInputStream pipedInputStream0 = new PipedInputStream(1);\n      BufferedInputStream bufferedInputStream0 = new BufferedInputStream(pipedInputStream0, (byte)119);\n      SequenceInputStream sequenceInputStream0 = new SequenceInputStream(bufferedInputStream0, pipedInputStream0);\n      Coder coder0 = new Coder();\n      coder0.properties = byteArray0;\n       \n        coders_LZMADecoder0.decode(sequenceInputStream0, coder0, byteArray0);"
    },
    {
        "focal_method": "    public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\n            throws IOException {\n        final ZipArchiveEntry ae = new ZipArchiveEntry(entry);\n        if (hasZip64Extra(ae)) {\n            // Will be re-added as required. this may make the file generated with this method\n            // somewhat smaller than standard mode,\n            // since standard mode is unable to remove the zip 64 header.\n            ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        }\n        final boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\n                && ae.getSize() != ArchiveEntry.SIZE_UNKNOWN\n                && ae.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN;\n        putArchiveEntry(ae, is2PhaseSource);\n        copyFromZipInputStream(rawStream);\n        closeCopiedEntry(is2PhaseSource);\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);\n      ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();\n      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(\"AUy(e'\", true);\n      zipArchiveOutputStream0.putArchiveEntry(zipArchiveEntry0);\n      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(\"AUy(e'\");\n      zipArchiveOutputStream0.addRawArchiveEntry(zipArchiveEntry0, mockFileInputStream0);\n      zipArchiveOutputStream0.addRawArchiveEntry(zipArchiveEntry0, mockFileInputStream0);\n      assertEquals(\"PK\\u0003\\u0004\\u0014\\u0000\\b\\b\\b\\u0000\\uFFFD\\uFFFDND\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0003\\u0000PK\\u0007\\b\\u0000\\u0000\\u0000\\u0000\\u0002\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000PK\\u0003\\u0004\\u0014\\u0000\\b\\b\\b\\u0000\\uFFFD\\uFFFDND\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000PK\\u0007\\b\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\uFFFDPK\\u0003\\u0004\\u0014\\u0000\\u0000\\b\\b\\u0000\\uFFFD\\uFFFDND\\u0000\\u0000\\u0000\\u0000\\u0002\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\", byteArrayOutputStream0.toString());\n}",
        "docstring": "/**\n     * Adds an archive entry with a raw input stream.\n     *\n     * If crc, size and compressed size are supplied on the entry, these values will be used as-is.\n     * Zip64 status is re-established based on the settings in this stream, and the supplied value\n     * is ignored.\n     *\n     * The entry is put and closed immediately.\n     *\n     * @param entry The archive entry to add\n     * @param rawStream The raw input stream of a different entry. May be compressed/encrypted.\n     * @throws IOException If copying fails\n     */",
        "id": "235",
        "project": "Compress",
        "bug_num": "43",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, zipArchiveOutputStream0.isAutoFlush());",
        "prefix": "ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      ZipArchiveOutputStream zipArchiveOutputStream0 = new ZipArchiveOutputStream(byteArrayOutputStream0);\n      ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();\n      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(\"AUy(e'\", true);\n      zipArchiveOutputStream0.putArchiveEntry(zipArchiveEntry0);\n      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(\"AUy(e'\");\n      zipArchiveOutputStream0.addRawArchiveEntry(zipArchiveEntry0, mockFileInputStream0);\n      zipArchiveOutputStream0.addRawArchiveEntry(zipArchiveEntry0, mockFileInputStream0);"
    },
    {
        "focal_method": "    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }",
        "test_prefix": "  public void test19()  throws Throwable  {\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();\n      ZipLong zipLong0 = ZipLong.AED_SIG;\n      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField1 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);\n      byte[] byteArray0 = zip64ExtendedInformationExtraField1.getCentralDirectoryData();\n      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 24);\n      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, true, true, true);\n      assertNotSame(zip64ExtendedInformationExtraField0, zip64ExtendedInformationExtraField1);\n}",
        "docstring": "/**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */",
        "id": "236",
        "project": "Compress",
        "bug_num": "19",
        "test_name": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField_ESTest::test19",
        "except_pred": "0",
        "assert_pred": "assertEquals(24, zip64ExtendedInformationExtraField0.getSize());",
        "prefix": "Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();\n      ZipLong zipLong0 = ZipLong.AED_SIG;\n      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField1 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);\n      byte[] byteArray0 = zip64ExtendedInformationExtraField1.getCentralDirectoryData();\n      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 24);\n      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, true, true, true);"
    },
    {
        "focal_method": "    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }",
        "test_prefix": "  public void test19()  throws Throwable  {\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();\n      ZipLong zipLong0 = ZipLong.AED_SIG;\n      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField1 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);\n      byte[] byteArray0 = zip64ExtendedInformationExtraField1.getCentralDirectoryData();\n      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 24);\n      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, true, true, true);\n  }",
        "docstring": "/**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */",
        "id": "237",
        "project": "Compress",
        "bug_num": "19",
        "test_name": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField_ESTest::test19",
        "except_pred": "0",
        "assert_pred": "assertEquals(24, zip64ExtendedInformationExtraField0.getSize());",
        "prefix": "Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField();\n      ZipLong zipLong0 = ZipLong.AED_SIG;\n      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField1 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);\n      byte[] byteArray0 = zip64ExtendedInformationExtraField1.getCentralDirectoryData();\n      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 24);\n      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, true, true, true);"
    },
    {
        "focal_method": "    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      ZipLong zipLong0 = ZipLong.AED_SIG;\n      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);\n      byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();\n      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 22);\n      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, false, true, false);\n  }",
        "docstring": "/**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */",
        "id": "238",
        "project": "Compress",
        "bug_num": "19",
        "test_name": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField_ESTest::test23",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, zip64ExtendedInformationExtraField0.getBinaryLength());",
        "prefix": "ZipLong zipLong0 = ZipLong.AED_SIG;\n      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);\n      byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();\n      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 22);\n      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(false, false, true, false);"
    },
    {
        "focal_method": "    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += WORD;\n            }\n        }\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      ZipLong zipLong0 = ZipLong.AED_SIG;\n      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);\n      byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();\n      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 16);\n      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(true, false, false, true);\n  }",
        "docstring": "/**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */",
        "id": "239",
        "project": "Compress",
        "bug_num": "19",
        "test_name": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField_ESTest::test24",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, zip64ExtendedInformationExtraField0.getBinaryLength());",
        "prefix": "ZipLong zipLong0 = ZipLong.AED_SIG;\n      ZipEightByteInteger zipEightByteInteger0 = new ZipEightByteInteger((-1L));\n      Zip64ExtendedInformationExtraField zip64ExtendedInformationExtraField0 = new Zip64ExtendedInformationExtraField(zipEightByteInteger0, zipEightByteInteger0, zipEightByteInteger0, zipLong0);\n      byte[] byteArray0 = zip64ExtendedInformationExtraField0.getCentralDirectoryData();\n      zip64ExtendedInformationExtraField0.parseFromCentralDirectoryData(byteArray0, 1, 16);\n      zip64ExtendedInformationExtraField0.reparseCentralDirectoryData(true, false, false, true);"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        if (!this.closed) {\n            super.close();\n            this.closed = true;\n        }\n    }",
        "test_prefix": "  public void test01()  throws Throwable  {\n      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);\n      cpioArchiveOutputStream0.close();\n      assertEquals(\"q\\uFFFD\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0001\\u0000\\u0000\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\u0000\\u000B\\u0000\\u0000\\u0000\\u0000TRAILER!!!\\u0000\\u0000\", byteArrayOutputStream0.toString());\n}",
        "docstring": "/**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */",
        "id": "240",
        "project": "Compress",
        "bug_num": "1",
        "test_name": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream_ESTest::test01",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, byteArrayOutputStream0.size());",
        "prefix": "ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)8);\n      cpioArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        if (!this.closed) {\n            super.close();\n            this.closed = true;\n        }\n    }",
        "test_prefix": "  public void test04()  throws Throwable  {\n      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)4);\n      cpioArchiveOutputStream0.close();\n      assertEquals(\"0707070000000000000000000000000000000000010000007777777777700001300000000000TRAILER!!!\\u0000\", byteArrayOutputStream0.toString());\n}",
        "docstring": "/**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */",
        "id": "241",
        "project": "Compress",
        "bug_num": "1",
        "test_name": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream_ESTest::test04",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, byteArrayOutputStream0.size());",
        "prefix": "ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)4);\n      cpioArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        if (!this.closed) {\n            super.close();\n            this.closed = true;\n        }\n    }",
        "test_prefix": "  public void test06()  throws Throwable  {\n      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)2);\n      cpioArchiveOutputStream0.close();\n      assertEquals(\"0707020000000000000000000000000000000000000001ffffffff00000000000000000000000000000000000000000000000b00000000TRAILER!!!\\u0000\\u0000\\u0000\\u0000\", byteArrayOutputStream0.toString());\n}",
        "docstring": "/**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */",
        "id": "242",
        "project": "Compress",
        "bug_num": "1",
        "test_name": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream_ESTest::test06",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, byteArrayOutputStream0.size());",
        "prefix": "ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0, (short)2);\n      cpioArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public void close() throws IOException {\n        if (!this.closed) {\n            super.close();\n            this.closed = true;\n        }\n    }",
        "test_prefix": "  public void test21()  throws Throwable  {\n      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0);\n      cpioArchiveOutputStream0.close();\n      cpioArchiveOutputStream0.close();\n      assertEquals(\"0707010000000000000000000000000000000000000001ffffffff00000000000000000000000000000000000000000000000b00000000TRAILER!!!\\u0000\\u0000\\u0000\\u0000\", byteArrayOutputStream0.toString());\n}",
        "docstring": "/**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */",
        "id": "243",
        "project": "Compress",
        "bug_num": "1",
        "test_name": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream_ESTest::test21",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, byteArrayOutputStream0.size());",
        "prefix": "ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();\n      CpioArchiveOutputStream cpioArchiveOutputStream0 = new CpioArchiveOutputStream(byteArrayOutputStream0);\n      cpioArchiveOutputStream0.close();\n      cpioArchiveOutputStream0.close();"
    },
    {
        "focal_method": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        ZipArchiveEntry other = (ZipArchiveEntry) obj;\n        if (name == null) {\n            if (other.name != null) {\n                return false;\n            }\n        } else if (!name.equals(other.name)) {\n            return false;\n        }\n        return true;\n    }",
        "test_prefix": "  public void test29()  throws Throwable  {\n      ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();\n      ZipArchiveEntry zipArchiveEntry1 = new ZipArchiveEntry(\"y\");\n      boolean boolean0 = zipArchiveEntry1.equals(zipArchiveEntry0);\n      assertFalse(boolean0);\n}",
        "docstring": "",
        "id": "244",
        "project": "Compress",
        "bug_num": "6",
        "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry_ESTest::test29",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "ZipArchiveEntry zipArchiveEntry0 = new ZipArchiveEntry();\n      ZipArchiveEntry zipArchiveEntry1 = new ZipArchiveEntry(\"y\");\n      boolean boolean0 = zipArchiveEntry1.equals(zipArchiveEntry0);"
    },
    {
        "focal_method": "    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }",
        "test_prefix": "  public void test15()  throws Throwable  {\n      byte[] byteArray0 = new byte[36];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(6, byteArray0, 6, 6);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, 6, 12);\n      assertEquals(6L, long0);\n}",
        "docstring": "/** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */",
        "id": "245",
        "project": "Compress",
        "bug_num": "17",
        "test_name": "org.apache.commons.compress.archivers.tar.TarUtils_ESTest::test15",
        "except_pred": "0",
        "assert_pred": "assertEquals(0L, long0);",
        "prefix": "byte[] byteArray0 = new byte[36];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(6, byteArray0, 6, 6);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, 6, 12);"
    },
    {
        "focal_method": "    public static long parseOctalOrBinary(final byte[] buffer, final int offset,\n                                          final int length) {\n\n        if ((buffer[offset] & 0x80) == 0) {\n            return parseOctal(buffer, offset, length);\n        }\n        final boolean negative = buffer[offset] == (byte) 0xff;\n        if (length < 9) {\n            return parseBinaryLong(buffer, offset, length, negative);\n        }\n        return parseBinaryBigInteger(buffer, offset, length, negative);\n    }",
        "test_prefix": "  public void test15()  throws Throwable  {\n      byte[] byteArray0 = new byte[36];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(6, byteArray0, 6, 6);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, 6, 12);\n  }",
        "docstring": "/** \n     * Compute the value contained in a byte buffer.  If the most\n     * significant bit of the first byte in the buffer is set, this\n     * bit is ignored and the rest of the buffer is interpreted as a\n     * binary number.  Otherwise, the buffer is interpreted as an\n     * octal number as per the parseOctal function above.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The long value of the octal or binary string.\n     * @throws IllegalArgumentException if the trailing space/NUL is\n     * missing or an invalid byte is detected in an octal number, or\n     * if a binary number would exceed the size of a signed long\n     * 64-bit integer.\n     * @since 1.4\n     */",
        "id": "246",
        "project": "Compress",
        "bug_num": "17",
        "test_name": "org.apache.commons.compress.archivers.tar.TarUtils_ESTest::test15",
        "except_pred": "0",
        "assert_pred": "assertEquals(0L, long0);",
        "prefix": "byte[] byteArray0 = new byte[36];\n      int int0 = TarUtils.formatLongOctalOrBinaryBytes(6, byteArray0, 6, 6);\n      long long0 = TarUtils.parseOctalOrBinary(byteArray0, 6, 12);"
    },
    {
        "focal_method": "    public void writeEmbeddedObject(Object object) throws IOException {\n        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n                this);\n    }",
        "test_prefix": "  public void test45()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);\n      ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);\n      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-2660), (ObjectCodec) null, byteArrayBuilder0);\n      uTF8JsonGenerator0.writeEmbeddedObject((Object) null);\n      assertEquals(57343, GeneratorBase.SURR2_LAST);\n}",
        "docstring": "/**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */",
        "id": "247",
        "project": "JacksonCore",
        "bug_num": "20",
        "test_name": "com.fasterxml.jackson.core.JsonGenerator_ESTest::test45",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\", uTF8JsonGenerator0.getEncoding());",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);\n      ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);\n      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-2660), (ObjectCodec) null, byteArrayBuilder0);\n      uTF8JsonGenerator0.writeEmbeddedObject((Object) null);"
    },
    {
        "focal_method": "    public void writeEmbeddedObject(Object object) throws IOException {\n        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n                this);\n    }",
        "test_prefix": "  public void test45()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);\n      ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);\n      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-2660), (ObjectCodec) null, byteArrayBuilder0);\n      uTF8JsonGenerator0.writeEmbeddedObject((Object) null);\n  }",
        "docstring": "/**\n     * Method that can be called on backends that support passing opaque datatypes of\n     * non-JSON formats\n     *\n     * @since 2.8\n     */",
        "id": "248",
        "project": "JacksonCore",
        "bug_num": "20",
        "test_name": "com.fasterxml.jackson.core.JsonGenerator_ESTest::test45",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\", uTF8JsonGenerator0.getEncoding());",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, false);\n      ByteArrayBuilder byteArrayBuilder0 = new ByteArrayBuilder(bufferRecycler0);\n      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, (-2660), (ObjectCodec) null, byteArrayBuilder0);\n      uTF8JsonGenerator0.writeEmbeddedObject((Object) null);"
    },
    {
        "focal_method": "    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        // but above intended maximum, slow to increase by 25%\n        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }",
        "test_prefix": "  public void test45()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      char[] charArray0 = textBuffer0.getCurrentSegment();\n      textBuffer0.expandCurrentSegment(262144);\n      char[] charArray1 = textBuffer0.expandCurrentSegment();\n      assertEquals(327680, charArray1.length);\n}",
        "docstring": "/**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */",
        "id": "249",
        "project": "JacksonCore",
        "bug_num": "4",
        "test_name": "com.fasterxml.jackson.core.util.TextBuffer_ESTest::test45",
        "except_pred": "0",
        "assert_pred": "assertFalse(charArray1.equals(charArray0));",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      char[] charArray0 = textBuffer0.getCurrentSegment();\n      textBuffer0.expandCurrentSegment(262144);\n      char[] charArray1 = textBuffer0.expandCurrentSegment();"
    },
    {
        "focal_method": "    public int writeValue() {\n        // Most likely, object:\n        if (_type == TYPE_OBJECT) {\n            _gotName = false;\n            ++_index;\n            return STATUS_OK_AFTER_COLON;\n        }\n\n        // Ok, array?\n        if (_type == TYPE_ARRAY) {\n            int ix = _index;\n            ++_index;\n            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n        }\n        \n        // Nope, root context\n        // No commas within root context, but need space\n        ++_index;\n        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      DupDetector dupDetector0 = DupDetector.rootDetector((JsonParser) null);\n      JsonWriteContext jsonWriteContext0 = JsonWriteContext.createRootContext(dupDetector0);\n      JsonWriteContext jsonWriteContext1 = jsonWriteContext0.createChildObjectContext();\n      int int0 = jsonWriteContext1.writeValue();\n      assertEquals(5, int0);\n}",
        "docstring": "",
        "id": "250",
        "project": "JacksonCore",
        "bug_num": "7",
        "test_name": "com.fasterxml.jackson.core.json.JsonWriteContext_ESTest::test12",
        "except_pred": "0",
        "assert_pred": "assertEquals(dupDetector0.getType(), int0);",
        "prefix": "DupDetector dupDetector0 = DupDetector.rootDetector((JsonParser) null);\n      JsonWriteContext jsonWriteContext0 = JsonWriteContext.createRootContext(dupDetector0);\n      JsonWriteContext jsonWriteContext1 = jsonWriteContext0.createChildObjectContext();\n      int int0 = jsonWriteContext1.writeValue();"
    },
    {
        "focal_method": "    public boolean isResourceManaged() { return _managedResource; }",
        "test_prefix": "  public void test22()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      Object object0 = new Object();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);\n      iOContext0.allocWriteEncodingBuffer();\n      byte[] byteArray0 = iOContext0.allocReadIOBuffer();\n      iOContext0.releaseWriteEncodingBuffer(byteArray0);\n      assertTrue(iOContext0.isResourceManaged());\n}",
        "docstring": "",
        "id": "251",
        "project": "JacksonCore",
        "bug_num": "14",
        "test_name": "com.fasterxml.jackson.core.io.IOContext_ESTest::test22",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, iOContext0.isResourceManaged());",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      Object object0 = new Object();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);\n      iOContext0.allocWriteEncodingBuffer();\n      byte[] byteArray0 = iOContext0.allocReadIOBuffer();\n      iOContext0.releaseWriteEncodingBuffer(byteArray0);"
    },
    {
        "focal_method": "    public void releaseWriteEncodingBuffer(byte[] buf) {\n        if (buf != null) {\n            /* Let's do sanity checks to ensure once-and-only-once release,\n             * as well as avoiding trying to release buffers not owned\n             */\n            _verifyRelease(buf, _writeEncodingBuffer);\n            _writeEncodingBuffer = null;\n            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER, buf);\n        }\n    }",
        "test_prefix": "  public void test22()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      Object object0 = new Object();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);\n      iOContext0.allocWriteEncodingBuffer();\n      byte[] byteArray0 = iOContext0.allocReadIOBuffer();\n      iOContext0.releaseWriteEncodingBuffer(byteArray0);\n  }",
        "docstring": "",
        "id": "252",
        "project": "JacksonCore",
        "bug_num": "14",
        "test_name": "com.fasterxml.jackson.core.io.IOContext_ESTest::test22",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, iOContext0.useDirectByteBuffer);",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      Object object0 = new Object();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, object0, true);\n      iOContext0.allocWriteEncodingBuffer();\n      byte[] byteArray0 = iOContext0.allocReadIOBuffer();\n      iOContext0.releaseWriteEncodingBuffer(byteArray0);"
    },
    {
        "focal_method": "    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }",
        "test_prefix": "  public void test27()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.resetWithEmpty();\n      char[] charArray0 = textBuffer0.getTextBuffer();\n      assertNotNull(charArray0);\n}",
        "docstring": "",
        "id": "253",
        "project": "JacksonCore",
        "bug_num": "8",
        "test_name": "com.fasterxml.jackson.core.util.TextBuffer_ESTest::test27",
        "except_pred": "0",
        "assert_pred": "assertNotNull(charArray0);",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.resetWithEmpty();\n      char[] charArray0 = textBuffer0.getTextBuffer();"
    },
    {
        "focal_method": "    public Boolean nextBooleanValue()\n        throws IOException, JsonParseException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        switch (nextToken()) {\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        default:\n        \treturn null;\n        }\n    }",
        "test_prefix": "  public void test26()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, \"1IoL_.}7~~\\\"HL_r*\", false);\n      StringReader stringReader0 = new StringReader(\"0JMmtsG8ryBAGj-U!\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);\n      try { \n        readerBasedJsonParser0.nextBooleanValue();\n        fail(\"Expecting exception: IOException\");\n      } catch(IOException e) {\n         //\n         // Unexpected character ('J' (code 74)): Expected space separating root-level values\n         //  at [Source: java.lang.String@0000000014; line: 1, column: 3]\n         //\n         verifyException(\"com.fasterxml.jackson.core.JsonParser\", e);\n      }\n  }",
        "docstring": "",
        "id": "254",
        "project": "JacksonCore",
        "bug_num": "2",
        "test_name": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser_ESTest::test26",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, \"1IoL_.}7~~\\\"HL_r*\", false);\n      StringReader stringReader0 = new StringReader(\"0JMmtsG8ryBAGj-U!\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);\n       \n        readerBasedJsonParser0.nextBooleanValue();"
    },
    {
        "focal_method": "    public JsonToken nextToken()\n        throws IOException, JsonParseException\n    {\n        _numTypesValid = NR_UNKNOWN;\n\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n\n        /* First, need to ensure we know the starting location of token\n         * after skipping leading white space\n         */\n        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n        // finally: clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            if (i != INT_COMMA) {\n                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n            i = _skipWS();\n        }\n\n        /* And should we now have a name? Always true for\n         * Object contexts, since the intermediate 'expect-value'\n         * state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n           // First, field name itself:\n            String name = _parseName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipWS();\n            if (i != INT_COLON) {\n                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n            }\n            i = _skipWS();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parseNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }",
        "test_prefix": "  public void test27()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);\n      StringReader stringReader0 = new StringReader(\"1IoL_.}7~~\\\"HL_r*\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1722), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);\n      try { \n        readerBasedJsonParser0.nextToken();\n        fail(\"Expecting exception: IOException\");\n      } catch(IOException e) {\n         //\n         // Unexpected character ('I' (code 73)): Expected space separating root-level values\n         //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000015; line: 1, column: 3]\n         //\n         verifyException(\"com.fasterxml.jackson.core.JsonParser\", e);\n      }\n  }",
        "docstring": "/**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */",
        "id": "255",
        "project": "JacksonCore",
        "bug_num": "2",
        "test_name": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser_ESTest::test27",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);\n      StringReader stringReader0 = new StringReader(\"1IoL_.}7~~\\\"HL_r*\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, (-1722), stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);\n       \n        readerBasedJsonParser0.nextToken();"
    },
    {
        "focal_method": "    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n    }",
        "test_prefix": "  public void test28()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);\n      StringReader stringReader0 = new StringReader(\"x 2`=sNFw!\");\n      ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      int int0 = stringReader0.read();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);\n      SerializedString serializedString0 = new SerializedString(\"com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer\");\n      try { \n        readerBasedJsonParser0.nextFieldName(serializedString0);\n        fail(\"Expecting exception: IOException\");\n      } catch(IOException e) {\n         //\n         // Unexpected character ('`' (code 96)): Expected space separating root-level values\n         //  at [Source: com.fasterxml.jackson.core.util.BufferRecycler@0000000016; line: 1, column: 4]\n         //\n         verifyException(\"com.fasterxml.jackson.core.JsonParser\", e);\n      }\n  }",
        "docstring": "",
        "id": "256",
        "project": "JacksonCore",
        "bug_num": "2",
        "test_name": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser_ESTest::test28",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);\n      StringReader stringReader0 = new StringReader(\"x 2`=sNFw!\");\n      ObjectCodec objectCodec0 = mock(ObjectCodec.class, new ViolatedAssumptionAnswer());\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      int int0 = stringReader0.read();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 2000, stringReader0, objectCodec0, charsToNameCanonicalizer0);\n      SerializedString serializedString0 = new SerializedString(\"com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer\");\n       \n        readerBasedJsonParser0.nextFieldName(serializedString0);"
    },
    {
        "focal_method": "    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if (_inputStart >= 0) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if (_segmentSize == 0) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }",
        "test_prefix": "  public void test29()  throws Throwable  {\n      TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);\n      textBuffer0.contentsAsArray();\n      try { \n        textBuffer0.contentsAsDecimal();\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // Value \\\"\\\" can not be represented as BigDecimal\n         //\n         verifyException(\"com.fasterxml.jackson.core.io.NumberInput\", e);\n      }\n  }",
        "docstring": "/**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */",
        "id": "257",
        "project": "JacksonCore",
        "bug_num": "1",
        "test_name": "com.fasterxml.jackson.core.util.TextBuffer_ESTest::test29",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TextBuffer textBuffer0 = new TextBuffer((BufferRecycler) null);\n      textBuffer0.contentsAsArray();\n       \n        textBuffer0.contentsAsDecimal();"
    },
    {
        "focal_method": "    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if (_inputStart >= 0) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if (_segmentSize == 0) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }",
        "test_prefix": "  public void test30()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.getCurrentSegment();\n      try { \n        textBuffer0.contentsAsDecimal();\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // Value \\\"\\\" can not be represented as BigDecimal\n         //\n         verifyException(\"com.fasterxml.jackson.core.io.NumberInput\", e);\n      }\n  }",
        "docstring": "/**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */",
        "id": "258",
        "project": "JacksonCore",
        "bug_num": "1",
        "test_name": "com.fasterxml.jackson.core.util.TextBuffer_ESTest::test30",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.getCurrentSegment();\n       \n        textBuffer0.contentsAsDecimal();"
    },
    {
        "focal_method": "    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if (_inputStart >= 0) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if (_segmentSize == 0) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }",
        "test_prefix": "  public void test31()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      BufferRecycler.CharBufferType bufferRecycler_CharBufferType0 = BufferRecycler.CharBufferType.TOKEN_BUFFER;\n      char[] charArray0 = bufferRecycler0.allocCharBuffer(bufferRecycler_CharBufferType0);\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.resetWithShared(charArray0, 1, 1);\n      try { \n        textBuffer0.contentsAsDecimal();\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // Value \\\"\\u0000\\\" can not be represented as BigDecimal\n         //\n         verifyException(\"com.fasterxml.jackson.core.io.NumberInput\", e);\n      }\n  }",
        "docstring": "/**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */",
        "id": "259",
        "project": "JacksonCore",
        "bug_num": "1",
        "test_name": "com.fasterxml.jackson.core.util.TextBuffer_ESTest::test31",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      BufferRecycler.CharBufferType bufferRecycler_CharBufferType0 = BufferRecycler.CharBufferType.TOKEN_BUFFER;\n      char[] charArray0 = bufferRecycler0.allocCharBuffer(bufferRecycler_CharBufferType0);\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.resetWithShared(charArray0, 1, 1);\n       \n        textBuffer0.contentsAsDecimal();"
    },
    {
        "focal_method": "    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if (_inputStart >= 0) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if (_segmentSize == 0) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }",
        "test_prefix": "  public void test32()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.getCurrentSegment();\n      textBuffer0.setCurrentLength(2000);\n      textBuffer0.append('7');\n      try { \n        textBuffer0.contentsAsDecimal();\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // Value \\\"\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u00007\\\" can not be represented as BigDecimal\n         //\n         verifyException(\"com.fasterxml.jackson.core.io.NumberInput\", e);\n      }\n  }",
        "docstring": "/**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */",
        "id": "260",
        "project": "JacksonCore",
        "bug_num": "1",
        "test_name": "com.fasterxml.jackson.core.util.TextBuffer_ESTest::test32",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.getCurrentSegment();\n      textBuffer0.setCurrentLength(2000);\n      textBuffer0.append('7');\n       \n        textBuffer0.contentsAsDecimal();"
    },
    {
        "focal_method": "    public BigDecimal contentsAsDecimal()\n        throws NumberFormatException\n    {\n        // Already got a pre-cut array?\n        if (_resultArray != null) {\n            return NumberInput.parseBigDecimal(_resultArray);\n        }\n        // Or a shared buffer?\n        if (_inputStart >= 0) {\n            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);\n        }\n        // Or if not, just a single buffer (the usual case)\n        if (_segmentSize == 0) {\n            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);\n        }\n        // If not, let's just get it aggregated...\n        return NumberInput.parseBigDecimal(contentsAsArray());\n    }",
        "test_prefix": "  public void test44()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.resetWithShared((char[]) null, 2000, 2000);\n      // Undeclared exception!\n      try { \n        textBuffer0.contentsAsDecimal();\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n         //\n         // no message in exception (getMessage() returned null)\n         //\n         verifyException(\"java.util.Arrays\", e);\n      }\n  }",
        "docstring": "/**\n     * Convenience method for converting contents of the buffer\n     * into a {@link BigDecimal}.\n     */",
        "id": "261",
        "project": "JacksonCore",
        "bug_num": "1",
        "test_name": "com.fasterxml.jackson.core.util.TextBuffer_ESTest::test44",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      TextBuffer textBuffer0 = new TextBuffer(bufferRecycler0);\n      textBuffer0.resetWithShared((char[]) null, 2000, 2000);\n      // Undeclared exception!\n       \n        textBuffer0.contentsAsDecimal();"
    },
    {
        "focal_method": "    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n    {\n            return new BigDecimal(numStr);\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      char[] charArray0 = new char[3];\n      try { \n        NumberInput.parseBigDecimal(charArray0);\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // Value \\\"\\u0000\\u0000\\u0000\\\" can not be represented as BigDecimal\n         //\n         verifyException(\"com.fasterxml.jackson.core.io.NumberInput\", e);\n      }\n  }",
        "docstring": "",
        "id": "262",
        "project": "JacksonCore",
        "bug_num": "1",
        "test_name": "com.fasterxml.jackson.core.io.NumberInput_ESTest::test00",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "char[] charArray0 = new char[3];\n       \n        NumberInput.parseBigDecimal(charArray0);"
    },
    {
        "focal_method": "    public void writeNumber(short s) throws IOException\n    {\n        _verifyValueWrite(WRITE_NUMBER);\n        // up to 5 digits and possible minus sign\n        if ((_outputTail + 6) >= _outputEnd) {\n            _flushBuffer();\n        }\n        if (_cfgNumbersAsStrings) {\n            _writeQuotedShort(s);\n            return;\n        }\n        _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n    }",
        "test_prefix": "  public void test69()  throws Throwable  {\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);\n      MockFile mockFile0 = new MockFile(\"i]mir@\");\n      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);\n      byte[] byteArray0 = new byte[1];\n      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 154, true);\n      uTF8JsonGenerator0.writeString((char[]) null, 2, 0);\n      // Undeclared exception!\n      try { \n        uTF8JsonGenerator0.writeNumber((-1.0F));\n        fail(\"Expecting exception: ArrayIndexOutOfBoundsException\");\n      } catch(ArrayIndexOutOfBoundsException e) {\n         //\n         // 1\n         //\n         verifyException(\"com.fasterxml.jackson.core.json.UTF8JsonGenerator\", e);\n      }\n  }",
        "docstring": "",
        "id": "263",
        "project": "JacksonCore",
        "bug_num": "17",
        "test_name": "com.fasterxml.jackson.core.json.UTF8JsonGenerator_ESTest::test69",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, bufferRecycler0, true);\n      MockFile mockFile0 = new MockFile(\"i]mir@\");\n      MockFileOutputStream mockFileOutputStream0 = new MockFileOutputStream(mockFile0);\n      byte[] byteArray0 = new byte[1];\n      UTF8JsonGenerator uTF8JsonGenerator0 = new UTF8JsonGenerator(iOContext0, 1, (ObjectCodec) null, mockFileOutputStream0, byteArray0, 154, true);\n      uTF8JsonGenerator0.writeString((char[]) null, 2, 0);\n      // Undeclared exception!\n       \n        uTF8JsonGenerator0.writeNumber((-1.0F));"
    },
    {
        "focal_method": "    public int getMatchCount() {\n        return _matchCount;\n    }",
        "test_prefix": "  public void test43()  throws Throwable  {\n      TokenFilter tokenFilter0 = new TokenFilter();\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true);\n      StringReader stringReader0 = new StringReader(\"[1D.Y`lbK6$\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);\n      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);\n      filteringParserDelegate0._nextToken2();\n      boolean boolean0 = filteringParserDelegate0.hasTokenId(33);\n      assertEquals(1, filteringParserDelegate0.getMatchCount());\n}",
        "docstring": "/**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */",
        "id": "264",
        "project": "JacksonCore",
        "bug_num": "22",
        "test_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate_ESTest::test43",
        "except_pred": "0",
        "assert_pred": "assertEquals(1, filteringParserDelegate0.getMatchCount());",
        "prefix": "TokenFilter tokenFilter0 = new TokenFilter();\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true);\n      StringReader stringReader0 = new StringReader(\"[1D.Y`lbK6$\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);\n      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);\n      filteringParserDelegate0._nextToken2();\n      boolean boolean0 = filteringParserDelegate0.hasTokenId(33);"
    },
    {
        "focal_method": "    public int getMatchCount() {\n        return _matchCount;\n    }",
        "test_prefix": "  public void test50()  throws Throwable  {\n      TokenFilter tokenFilter0 = new TokenFilter();\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true);\n      StringReader stringReader0 = new StringReader(\"[1D.Y`lbK6$\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);\n      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);\n      filteringParserDelegate0._nextToken2();\n      boolean boolean0 = filteringParserDelegate0.isExpectedStartArrayToken();\n      assertEquals(1, filteringParserDelegate0.getMatchCount());\n}",
        "docstring": "/**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */",
        "id": "265",
        "project": "JacksonCore",
        "bug_num": "22",
        "test_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate_ESTest::test50",
        "except_pred": "0",
        "assert_pred": "assertEquals(1166, filteringParserDelegate0.getMatchCount());",
        "prefix": "TokenFilter tokenFilter0 = new TokenFilter();\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, true);\n      StringReader stringReader0 = new StringReader(\"[1D.Y`lbK6$\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);\n      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);\n      filteringParserDelegate0._nextToken2();\n      boolean boolean0 = filteringParserDelegate0.isExpectedStartArrayToken();"
    },
    {
        "focal_method": "    public int getMatchCount() {\n        return _matchCount;\n    }",
        "test_prefix": "  public void test67()  throws Throwable  {\n      TokenFilter tokenFilter0 = new TokenFilter();\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, false);\n      StringReader stringReader0 = new StringReader(\"[1D.Y`lbK6$\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);\n      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);\n      FilteringParserDelegate filteringParserDelegate1 = new FilteringParserDelegate(filteringParserDelegate0, tokenFilter0, false, false);\n      filteringParserDelegate0.nextToken();\n      filteringParserDelegate1.nextValue();\n      assertEquals(1, filteringParserDelegate0.getMatchCount());\n}",
        "docstring": "/**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */",
        "id": "266",
        "project": "JacksonCore",
        "bug_num": "22",
        "test_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate_ESTest::test67",
        "except_pred": "0",
        "assert_pred": "assertEquals(266, filteringParserDelegate0.getMatchCount());",
        "prefix": "TokenFilter tokenFilter0 = new TokenFilter();\n      BufferRecycler bufferRecycler0 = new BufferRecycler();\n      IOContext iOContext0 = new IOContext(bufferRecycler0, tokenFilter0, false);\n      StringReader stringReader0 = new StringReader(\"[1D.Y`lbK6$\");\n      CharsToNameCanonicalizer charsToNameCanonicalizer0 = CharsToNameCanonicalizer.createRoot();\n      ReaderBasedJsonParser readerBasedJsonParser0 = new ReaderBasedJsonParser(iOContext0, 1266, stringReader0, (ObjectCodec) null, charsToNameCanonicalizer0);\n      FilteringParserDelegate filteringParserDelegate0 = new FilteringParserDelegate(readerBasedJsonParser0, tokenFilter0, true, true);\n      FilteringParserDelegate filteringParserDelegate1 = new FilteringParserDelegate(filteringParserDelegate0, tokenFilter0, false, false);\n      filteringParserDelegate0.nextToken();\n      filteringParserDelegate1.nextValue();"
    },
    {
        "focal_method": "    public Object generateId(Object forPojo) {\n        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n        //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n        //    need to use existing id if there is one:\n            id = generator.generateId(forPojo);\n        return id;\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      ObjectIdGenerators.IntSequenceGenerator objectIdGenerators_IntSequenceGenerator0 = new ObjectIdGenerators.IntSequenceGenerator();\n      WritableObjectId writableObjectId0 = new WritableObjectId(objectIdGenerators_IntSequenceGenerator0);\n      writableObjectId0.generateId(objectIdGenerators_IntSequenceGenerator0);\n      Object object0 = new Object();\n      Object object1 = writableObjectId0.generateId(object0);\n      assertEquals((-1), object1);\n}",
        "docstring": "",
        "id": "267",
        "project": "JacksonDatabind",
        "bug_num": "49",
        "test_name": "com.fasterxml.jackson.databind.ser.impl.WritableObjectId_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertSame(object0, object1);",
        "prefix": "ObjectIdGenerators.IntSequenceGenerator objectIdGenerators_IntSequenceGenerator0 = new ObjectIdGenerators.IntSequenceGenerator();\n      WritableObjectId writableObjectId0 = new WritableObjectId(objectIdGenerators_IntSequenceGenerator0);\n      writableObjectId0.generateId(objectIdGenerators_IntSequenceGenerator0);\n      Object object0 = new Object();\n      Object object1 = writableObjectId0.generateId(object0);"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test01()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      MapDeserializer mapDeserializer1 = new MapDeserializer(mapDeserializer0);\n      assertFalse(mapDeserializer1.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "268",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test01",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer1.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      MapDeserializer mapDeserializer1 = new MapDeserializer(mapDeserializer0);"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test02()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      JavaType javaType0 = mapDeserializer0.getValueType();\n      assertFalse(mapDeserializer0.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "269",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test02",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer0.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      JavaType javaType0 = mapDeserializer0.getValueType();"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class0, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 3980);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      mapDeserializer0.getContentType();\n      assertFalse(mapDeserializer0.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "270",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer0.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class0, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 3980);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      mapDeserializer0.getContentType();"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test08()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.class;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      Class<String> class2 = String.class;\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 1006);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();\n      Class<Error> class3 = Error.class;\n      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class3);\n      mapDeserializer0.withResolved(stdKeyDeserializer_StringKD0, (TypeDeserializer) null, mapDeserializer0, linkedHashSet0);\n      assertFalse(mapDeserializer0.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "271",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test08",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer0.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.class;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      Class<String> class2 = String.class;\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 1006);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();\n      Class<Error> class3 = Error.class;\n      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class3);\n      mapDeserializer0.withResolved(stdKeyDeserializer_StringKD0, (TypeDeserializer) null, mapDeserializer0, linkedHashSet0);"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.class;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      Class<MapperFeature> class2 = MapperFeature.class;\n      CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class2, 10);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, coreXMLDeserializers_Std0, (TypeDeserializer) null);\n      HashSet<String> hashSet0 = new HashSet<String>();\n      TypeFactory typeFactory0 = TypeFactory.defaultInstance();\n      ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);\n      Class<InputStream> class3 = InputStream.class;\n      AsWrapperTypeDeserializer asWrapperTypeDeserializer0 = new AsWrapperTypeDeserializer(collectionLikeType0, classNameIdResolver0, \"\", false, class3);\n      mapDeserializer0.withResolved((KeyDeserializer) null, asWrapperTypeDeserializer0, coreXMLDeserializers_Std0, hashSet0);\n      assertFalse(mapDeserializer0.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "272",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test09",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer0.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.class;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      Class<MapperFeature> class2 = MapperFeature.class;\n      CoreXMLDeserializers.Std coreXMLDeserializers_Std0 = new CoreXMLDeserializers.Std(class2, 10);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, coreXMLDeserializers_Std0, (TypeDeserializer) null);\n      HashSet<String> hashSet0 = new HashSet<String>();\n      TypeFactory typeFactory0 = TypeFactory.defaultInstance();\n      ClassNameIdResolver classNameIdResolver0 = new ClassNameIdResolver(simpleType0, typeFactory0);\n      Class<InputStream> class3 = InputStream.class;\n      AsWrapperTypeDeserializer asWrapperTypeDeserializer0 = new AsWrapperTypeDeserializer(collectionLikeType0, classNameIdResolver0, \"\", false, class3);\n      mapDeserializer0.withResolved((KeyDeserializer) null, asWrapperTypeDeserializer0, coreXMLDeserializers_Std0, hashSet0);"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test10()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      HashSet<String> hashSet0 = new HashSet<String>();\n      MapDeserializer mapDeserializer1 = mapDeserializer0.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0);\n      MapDeserializer mapDeserializer2 = mapDeserializer1.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0);\n      assertFalse(mapDeserializer0.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "273",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test10",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer2.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      HashSet<String> hashSet0 = new HashSet<String>();\n      MapDeserializer mapDeserializer1 = mapDeserializer0.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0);\n      MapDeserializer mapDeserializer2 = mapDeserializer1.withResolved((KeyDeserializer) null, (TypeDeserializer) null, fromStringDeserializer_Std0, hashSet0);"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test11()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      mapDeserializer0.setIgnorableProperties((String[]) null);\n      assertFalse(mapDeserializer0.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "274",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test11",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer0.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      mapDeserializer0.setIgnorableProperties((String[]) null);"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test13()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      String[] stringArray0 = new String[0];\n      mapDeserializer0.setIgnorableProperties(stringArray0);\n      assertFalse(mapDeserializer0.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "275",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test13",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer0.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.TYPE;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 6);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, (KeyDeserializer) null, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      String[] stringArray0 = new String[0];\n      mapDeserializer0.setIgnorableProperties(stringArray0);"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test15()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.class;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      Class<Error> class2 = Error.class;\n      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;\n      DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);\n      mapDeserializer0.resolve(defaultDeserializationContext_Impl0);\n      assertFalse(mapDeserializer0.isCachable());\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "276",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test15",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, mapDeserializer0.isCachable());",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.class;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      Class<Error> class2 = Error.class;\n      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      BeanDeserializerFactory beanDeserializerFactory0 = BeanDeserializerFactory.instance;\n      DefaultDeserializationContext.Impl defaultDeserializationContext_Impl0 = new DefaultDeserializationContext.Impl(beanDeserializerFactory0);\n      mapDeserializer0.resolve(defaultDeserializationContext_Impl0);"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.class;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      Class<Error> class2 = Error.class;\n      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      boolean boolean0 = mapDeserializer0.isCachable();\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "277",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      Class<Integer> class1 = Integer.class;\n      CollectionLikeType collectionLikeType0 = CollectionLikeType.construct(class1, simpleType0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, collectionLikeType0);\n      Class<Error> class2 = Error.class;\n      StdKeyDeserializer.StringKD stdKeyDeserializer_StringKD0 = StdKeyDeserializer.StringKD.forType(class2);\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class2, 9);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(collectionLikeType0, stdValueInstantiator0, stdKeyDeserializer_StringKD0, fromStringDeserializer_Std0, (TypeDeserializer) null);\n      boolean boolean0 = mapDeserializer0.isCachable();"
    },
    {
        "focal_method": "    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }",
        "test_prefix": "  public void test20()  throws Throwable  {\n      Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, simpleType0);\n      Class<Integer> class1 = Integer.class;\n      StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class1);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, stdKeyDeserializer0, (JsonDeserializer<Object>) null, (TypeDeserializer) null);\n      boolean boolean0 = mapDeserializer0.isCachable();\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */",
        "id": "278",
        "project": "JacksonDatabind",
        "bug_num": "12",
        "test_name": "com.fasterxml.jackson.databind.deser.std.MapDeserializer_ESTest::test20",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "Class<FilterInputStream> class0 = FilterInputStream.class;\n      SimpleType simpleType0 = SimpleType.constructUnsafe(class0);\n      StdValueInstantiator stdValueInstantiator0 = new StdValueInstantiator((DeserializationConfig) null, simpleType0);\n      Class<Integer> class1 = Integer.class;\n      StdKeyDeserializer stdKeyDeserializer0 = StdKeyDeserializer.forType(class1);\n      MapDeserializer mapDeserializer0 = new MapDeserializer(simpleType0, stdValueInstantiator0, stdKeyDeserializer0, (JsonDeserializer<Object>) null, (TypeDeserializer) null);\n      boolean boolean0 = mapDeserializer0.isCachable();"
    },
    {
        "focal_method": "    protected T _deserializeFromEmptyString() throws IOException {\n        return null;\n    }",
        "test_prefix": "  public void test35()  throws Throwable  {\n      Class<InetAddress> class0 = InetAddress.class;\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 8);\n      Object object0 = fromStringDeserializer_Std0._deserializeFromEmptyString();\n      assertEquals(\"\", object0.toString());\n}",
        "docstring": "",
        "id": "279",
        "project": "JacksonDatabind",
        "bug_num": "42",
        "test_name": "com.fasterxml.jackson.databind.deser.std.FromStringDeserializer_ESTest::test35",
        "except_pred": "0",
        "assert_pred": "assertNull(object0);",
        "prefix": "Class<InetAddress> class0 = InetAddress.class;\n      FromStringDeserializer.Std fromStringDeserializer_Std0 = new FromStringDeserializer.Std(class0, 8);\n      Object object0 = fromStringDeserializer_Std0._deserializeFromEmptyString();"
    },
    {
        "focal_method": "    public boolean isLenient() {\n        if (_lenient == null) {\n            // default is, I believe, true\n            return true;\n        }\n        return _lenient.booleanValue();\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      StdDateFormat stdDateFormat0 = new StdDateFormat();\n      stdDateFormat0.instance.setLenient(true);\n      assertTrue(stdDateFormat0.isLenient());\n}",
        "docstring": "/**\n     * Need to override since we need to keep track of leniency locally,\n     * and not via underlying {@link Calendar} instance like base class\n     * does.\n     */",
        "id": "280",
        "project": "JacksonDatabind",
        "bug_num": "36",
        "test_name": "com.fasterxml.jackson.databind.util.StdDateFormat_ESTest::test12",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, stdDateFormat0.isLenient());",
        "prefix": "StdDateFormat stdDateFormat0 = new StdDateFormat();\n      stdDateFormat0.instance.setLenient(true);"
    },
    {
        "focal_method": "    public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      StdDateFormat stdDateFormat0 = new StdDateFormat();\n      stdDateFormat0.instance.setLenient(true);\n  }",
        "docstring": "",
        "id": "281",
        "project": "JacksonDatabind",
        "bug_num": "36",
        "test_name": "com.fasterxml.jackson.databind.util.StdDateFormat_ESTest::test12",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"yyyy-MM-dd'T'HH:mm:ss\", stdDateFormat0.toPattern());",
        "prefix": "StdDateFormat stdDateFormat0 = new StdDateFormat();\n      stdDateFormat0.instance.setLenient(true);"
    },
    {
        "focal_method": "    public boolean isLenient() {\n        if (_lenient == null) {\n            // default is, I believe, true\n            return true;\n        }\n        return _lenient.booleanValue();\n    }",
        "test_prefix": "  public void test13()  throws Throwable  {\n      StdDateFormat stdDateFormat0 = new StdDateFormat();\n      stdDateFormat0.setLenient(false);\n      assertFalse(stdDateFormat0.isLenient());\n}",
        "docstring": "/**\n     * Need to override since we need to keep track of leniency locally,\n     * and not via underlying {@link Calendar} instance like base class\n     * does.\n     */",
        "id": "282",
        "project": "JacksonDatabind",
        "bug_num": "36",
        "test_name": "com.fasterxml.jackson.databind.util.StdDateFormat_ESTest::test13",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, stdDateFormat0.isLenient());",
        "prefix": "StdDateFormat stdDateFormat0 = new StdDateFormat();\n      stdDateFormat0.setLenient(false);"
    },
    {
        "focal_method": "    public StdDateFormat() {\n        _locale = DEFAULT_LOCALE;\n    }",
        "test_prefix": "  public void test13()  throws Throwable  {\n      StdDateFormat stdDateFormat0 = new StdDateFormat();\n      stdDateFormat0.setLenient(false);\n  }",
        "docstring": "",
        "id": "283",
        "project": "JacksonDatabind",
        "bug_num": "36",
        "test_name": "com.fasterxml.jackson.databind.util.StdDateFormat_ESTest::test13",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"yyyy-MM-dd'T'HH:mm:ss\", stdDateFormat0.toPattern());",
        "prefix": "StdDateFormat stdDateFormat0 = new StdDateFormat();\n      stdDateFormat0.setLenient(false);"
    },
    {
        "focal_method": "    public TreeTraversingParser(JsonNode n) { this(n, null); }",
        "test_prefix": "  public void test32()  throws Throwable  {\n      LongNode longNode0 = LongNode.valueOf((-9223372036854775808L));\n      TreeTraversingParser treeTraversingParser0 = new TreeTraversingParser(longNode0);\n      // Undeclared exception!\n      try { \n        treeTraversingParser0.getByteValue();\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n         //\n         // no message in exception (getMessage() returned null)\n         //\n         verifyException(\"com.fasterxml.jackson.databind.node.TreeTraversingParser\", e);\n      }\n  }",
        "docstring": "",
        "id": "284",
        "project": "JacksonDatabind",
        "bug_num": "106",
        "test_name": "com.fasterxml.jackson.databind.node.TreeTraversingParser_ESTest::test32",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "LongNode longNode0 = LongNode.valueOf((-9223372036854775808L));\n      TreeTraversingParser treeTraversingParser0 = new TreeTraversingParser(longNode0);\n      // Undeclared exception!\n       \n        treeTraversingParser0.getByteValue();"
    },
    {
        "focal_method": "    public long getLongValue() throws IOException {\n        final NumericNode node = (NumericNode) currentNumericNode();\n        return node.longValue();\n    }",
        "test_prefix": "  public void test34()  throws Throwable  {\n      LongNode longNode0 = LongNode.valueOf((-9223372036854775808L));\n      TreeTraversingParser treeTraversingParser0 = new TreeTraversingParser(longNode0);\n      // Undeclared exception!\n      try { \n        treeTraversingParser0.getLongValue();\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n         //\n         // no message in exception (getMessage() returned null)\n         //\n         verifyException(\"com.fasterxml.jackson.databind.node.TreeTraversingParser\", e);\n      }\n  }",
        "docstring": "",
        "id": "285",
        "project": "JacksonDatabind",
        "bug_num": "106",
        "test_name": "com.fasterxml.jackson.databind.node.TreeTraversingParser_ESTest::test34",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "LongNode longNode0 = LongNode.valueOf((-9223372036854775808L));\n      TreeTraversingParser treeTraversingParser0 = new TreeTraversingParser(longNode0);\n      // Undeclared exception!\n       \n        treeTraversingParser0.getLongValue();"
    },
    {
        "focal_method": "    public static JsonDeserializer<?> find(Class<?> rawType, String clsName)\n    {\n        if (_classNames.contains(clsName)) {\n            JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);\n            if (d != null) {\n                return d;\n            }\n            if (rawType == UUID.class) {\n                return new UUIDDeserializer();\n            }\n            if (rawType == StackTraceElement.class) {\n                return new StackTraceElementDeserializer();\n            }\n            if (rawType == AtomicBoolean.class) {\n                // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n                return new AtomicBooleanDeserializer();\n            }\n            if (rawType == ByteBuffer.class) {\n                return new ByteBufferDeserializer();\n            }\n        }\n        return null;\n    }",
        "test_prefix": "  public void test5()  throws Throwable  {\n      Class<Void> class0 = Void.class;\n      JsonDeserializer<?> jsonDeserializer0 = JdkDeserializers.find(class0, \"com.fasterxml.jackson.databind.JavaType\");\n      assertNotNull(jsonDeserializer0);\n}",
        "docstring": "",
        "id": "286",
        "project": "JacksonDatabind",
        "bug_num": "105",
        "test_name": "com.fasterxml.jackson.databind.deser.std.JdkDeserializers_ESTest::test5",
        "except_pred": "0",
        "assert_pred": "assertNull(jsonDeserializer0);",
        "prefix": "Class<Void> class0 = Void.class;\n      JsonDeserializer<?> jsonDeserializer0 = JdkDeserializers.find(class0, \"com.fasterxml.jackson.databind.JavaType\");"
    },
    {
        "focal_method": "    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }",
        "test_prefix": "  public void test03()  throws Throwable  {\n      SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;\n      ReferenceType referenceType0 = new ReferenceType(simpleType0, simpleType0);\n      String string0 = referenceType0.toString();\n      assertEquals(\"[reference type, class java.lang.Object<java.lang.Object><[simple type, class java.lang.Object]>]\", string0);\n}",
        "docstring": "",
        "id": "287",
        "project": "JacksonDatabind",
        "bug_num": "99",
        "test_name": "com.fasterxml.jackson.databind.type.ReferenceType_ESTest::test03",
        "except_pred": "0",
        "assert_pred": "assertNotNull(string0);",
        "prefix": "SimpleType simpleType0 = TypeFactory.CORE_TYPE_OBJECT;\n      ReferenceType referenceType0 = new ReferenceType(simpleType0, simpleType0);\n      String string0 = referenceType0.toString();"
    },
    {
        "focal_method": "    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n            gen.writeObject(_value);\n        }\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      POJONode pOJONode0 = new POJONode(\"b4axvGC0V\");\n      JsonFactory jsonFactory0 = new JsonFactory();\n      StringWriter stringWriter0 = new StringWriter();\n      JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((Writer) stringWriter0);\n      // Undeclared exception!\n      try { \n        pOJONode0.serialize(jsonGenerator0, (SerializerProvider) null);\n        fail(\"Expecting exception: NullPointerException\");\n      } catch(NullPointerException e) {\n         //\n         // no message in exception (getMessage() returned null)\n         //\n         verifyException(\"com.fasterxml.jackson.databind.node.POJONode\", e);\n      }\n  }",
        "docstring": "",
        "id": "288",
        "project": "JacksonDatabind",
        "bug_num": "97",
        "test_name": "com.fasterxml.jackson.databind.node.POJONode_ESTest::test18",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "POJONode pOJONode0 = new POJONode(\"b4axvGC0V\");\n      JsonFactory jsonFactory0 = new JsonFactory();\n      StringWriter stringWriter0 = new StringWriter();\n      JsonGenerator jsonGenerator0 = jsonFactory0.createGenerator((Writer) stringWriter0);\n      // Undeclared exception!\n       \n        pOJONode0.serialize(jsonGenerator0, (SerializerProvider) null);"
    },
    {
        "focal_method": "    public int getDenominator() {\n        return denominator;\n    }",
        "test_prefix": "  public void test28()  throws Throwable  {\n      Fraction fraction0 = Fraction.getFraction(0, 394);\n      Fraction fraction1 = fraction0.reduce();\n      assertEquals(1, fraction1.getDenominator());\n}",
        "docstring": "/**\n     * <p>Gets the denominator part of the fraction.</p>\n     *\n     * @return the denominator fraction part\n     */",
        "id": "289",
        "project": "Lang",
        "bug_num": "49",
        "test_name": "org.apache.commons.lang.math.Fraction_ESTest::test28",
        "except_pred": "0",
        "assert_pred": "assertEquals(394, fraction1.getDenominator());",
        "prefix": "Fraction fraction0 = Fraction.getFraction(0, 394);\n      Fraction fraction1 = fraction0.reduce();"
    },
    {
        "focal_method": "    public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false);\n    }",
        "test_prefix": "  public void test08()  throws Throwable  {\n      String string0 = \"<<\\\\u+ob%jNBH/\";\n      String string1 = StringEscapeUtils.escapeJava(string0);\n      assertEquals(\"<<\\\\\\\\u+ob%jNBH\\\\/\", string1);\n}",
        "docstring": "/**\n     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n     *\n     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn't say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */",
        "id": "290",
        "project": "Lang",
        "bug_num": "52",
        "test_name": "org.apache.commons.lang.StringEscapeUtils_ESTest::test08",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\\\\u+ob%jNBH/\", string1);",
        "prefix": "String string0 = \"<<\\\\u+ob%jNBH/\";\n      String string1 = StringEscapeUtils.escapeJava(string0);"
    },
    {
        "focal_method": "    public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false);\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      String string0 = StringEscapeUtils.escapeJava(\"3b#H/LYs'XYVNA3|'T\");\n      assertEquals(\"3b#H\\\\/LYs'XYVNA3|'T\", string0);\n}",
        "docstring": "/**\n     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n     *\n     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn't say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */",
        "id": "291",
        "project": "Lang",
        "bug_num": "52",
        "test_name": "org.apache.commons.lang.StringEscapeUtils_ESTest::test09",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"3b#H/LYs'XYVNA3|'T\", string0);",
        "prefix": "String string0 = StringEscapeUtils.escapeJava(\"3b#H/LYs'XYVNA3|'T\");"
    },
    {
        "focal_method": "    public int capacity() {\n        return buffer.length;\n    }",
        "test_prefix": "  public void test015()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder((String) null);\n      strBuilder0.appendFixedWidthPadRight((Object) null, 45, 'Z');\n      assertEquals(45, strBuilder0.capacity());\n}",
        "docstring": "/**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return the capacity\n     */",
        "id": "292",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test015",
        "except_pred": "0",
        "assert_pred": "assertEquals(8, strBuilder0.capacity());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder((String) null);\n      strBuilder0.appendFixedWidthPadRight((Object) null, 45, 'Z');"
    },
    {
        "focal_method": "    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }",
        "test_prefix": "  public void test015()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder((String) null);\n      strBuilder0.appendFixedWidthPadRight((Object) null, 45, 'Z');\n  }",
        "docstring": "/**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */",
        "id": "293",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test015",
        "except_pred": "0",
        "assert_pred": "assertEquals(0, strBuilder0.size);",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder((String) null);\n      strBuilder0.appendFixedWidthPadRight((Object) null, 45, 'Z');"
    },
    {
        "focal_method": "    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertNotNull(strBuilder1);\n}",
        "docstring": "/**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */",
        "id": "294",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertSame(strBuilder1, strBuilder0);",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertSame(strBuilder0, strBuilder1);\n}",
        "docstring": "/**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */",
        "id": "295",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertSame(strBuilder1, strBuilder0);",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertSame(strBuilder1, strBuilder0);\n}",
        "docstring": "/**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */",
        "id": "296",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertSame(strBuilder1, strBuilder0);",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public int length() {\n        return size;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertEquals(574, strBuilder0.length());\n}",
        "docstring": "/**\n     * Gets the length of the string builder.\n     *\n     * @return the length\n     */",
        "id": "297",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(574, strBuilder0.length());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public int size() {\n        return size;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertEquals(574, strBuilder0.size());\n}",
        "docstring": "/**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the\n     * API of Collections.\n     *\n     * @return the length\n     */",
        "id": "298",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(574, strBuilder1.size());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public String getNewLineText() {\n        return newLine;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertNull(strBuilder0.getNewLineText());\n}",
        "docstring": "/**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return the new line text, null means use system default\n     */",
        "id": "299",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\\n\", strBuilder1.getNewLineText());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public int capacity() {\n        return buffer.length;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertEquals(574, strBuilder0.capacity());\n}",
        "docstring": "/**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return the capacity\n     */",
        "id": "300",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(574, strBuilder1.capacity());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public boolean isEmpty() {\n        return size == 0;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertFalse(strBuilder0.isEmpty());\n}",
        "docstring": "/**\n     * Checks is the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the\n     * API of Collections.\n     *\n     * @return <code>true</code> if the size is <code>0</code>.\n     */",
        "id": "301",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, strBuilder1.isEmpty());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public String getNullText() {\n        return nullText;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertNull(strBuilder0.getNullText());\n}",
        "docstring": "/**\n     * Gets the text to be appended when null is added.\n     *\n     * @return the null text, null means no append\n     */",
        "id": "302",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertNull(strBuilder1.getNullText());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public int size() {\n        return size;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertEquals(574, strBuilder1.size());\n}",
        "docstring": "/**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the\n     * API of Collections.\n     *\n     * @return the length\n     */",
        "id": "303",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(574, strBuilder1.size());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public boolean isEmpty() {\n        return size == 0;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertFalse(strBuilder1.isEmpty());\n}",
        "docstring": "/**\n     * Checks is the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the\n     * API of Collections.\n     *\n     * @return <code>true</code> if the size is <code>0</code>.\n     */",
        "id": "304",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, strBuilder1.isEmpty());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public String getNewLineText() {\n        return newLine;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertNull(strBuilder1.getNewLineText());\n}",
        "docstring": "/**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return the new line text, null means use system default\n     */",
        "id": "305",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"\\n\", strBuilder1.getNewLineText());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public int capacity() {\n        return buffer.length;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertEquals(574, strBuilder1.capacity());\n}",
        "docstring": "/**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return the capacity\n     */",
        "id": "306",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(574, strBuilder1.capacity());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public String getNullText() {\n        return nullText;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertNull(strBuilder1.getNullText());\n}",
        "docstring": "/**\n     * Gets the text to be appended when null is added.\n     *\n     * @return the null text, null means no append\n     */",
        "id": "307",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertNull(strBuilder1.getNullText());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public int length() {\n        return size;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n      assertEquals(574, strBuilder1.length());\n}",
        "docstring": "/**\n     * Gets the length of the string builder.\n     *\n     * @return the length\n     */",
        "id": "308",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertEquals(574, strBuilder0.length());",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
        "test_prefix": "  public void test132()  throws Throwable  {\n      StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');\n  }",
        "docstring": "/**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */",
        "id": "309",
        "project": "Lang",
        "bug_num": "47",
        "test_name": "org.apache.commons.lang.text.StrBuilder_ESTest::test132",
        "except_pred": "0",
        "assert_pred": "assertSame(strBuilder1, strBuilder0);",
        "prefix": "StrBuilder strBuilder0 = new StrBuilder(574);\n      StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) null, 574, '\\'');"
    },
    {
        "focal_method": "    public static String escapeJava(String str) {\n        return escapeJavaStyleString(str, false);\n    }",
        "test_prefix": "  public void test09()  throws Throwable  {\n      String string0 = StringEscapeUtils.escapeJava(\"OZw9N)RwzH/\");\n      assertEquals(\"OZw9N)RwzH/\", string0);\n}",
        "docstring": "/**\n     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n     *\n     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n     *\n     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n     * <code>'t'</code>.</p>\n     *\n     * <p>The only difference between Java strings and JavaScript strings\n     * is that in JavaScript, a single quote must be escaped.</p>\n     *\n     * <p>Example:\n     * <pre>\n     * input string: He didn't say, \"Stop!\"\n     * output string: He didn't say, \\\"Stop!\\\"\n     * </pre>\n     * </p>\n     *\n     * @param str  String to escape values in, may be null\n     * @return String with escaped values, <code>null</code> if null string input\n     */",
        "id": "310",
        "project": "Lang",
        "bug_num": "46",
        "test_name": "org.apache.commons.lang.StringEscapeUtils_ESTest::test09",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"OZw9N)RwzH/\", string0);",
        "prefix": "String string0 = StringEscapeUtils.escapeJava(\"OZw9N)RwzH/\");"
    },
    {
        "focal_method": "    public static <T> T[] add(T[] array, T element) {\n        Class<?> type;\n        if (array != null){\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        @SuppressWarnings(\"unchecked\") // type must be T\n        T[] newArray = (T[]) copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }",
        "test_prefix": "  public void test349()  throws Throwable  {\n      // Undeclared exception!\n      try { \n        ArrayUtils.add((Object[]) null, (Object) null);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Arguments cannot both be null\n         //\n         verifyException(\"org.apache.commons.lang3.ArrayUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * If both are null, an IllegalArgumentException is thrown\n     * @since 2.1\n     * @throws IllegalArgumentException if both arguments are null\n     */",
        "id": "311",
        "project": "Lang",
        "bug_num": "35",
        "test_name": "org.apache.commons.lang3.ArrayUtils_ESTest::test349",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "// Undeclared exception!\n       \n        ArrayUtils.add((Object[]) null, (Object) null);"
    },
    {
        "focal_method": "    public static <T> T[] add(T[] array, T element) {\n        Class<?> type;\n        if (array != null){\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        @SuppressWarnings(\"unchecked\") // type must be T\n        T[] newArray = (T[]) copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }",
        "test_prefix": "  public void test352()  throws Throwable  {\n      // Undeclared exception!\n      try { \n        ArrayUtils.add((Integer[]) null, (-7), (Integer) null);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Array and element cannot both be null\n         //\n         verifyException(\"org.apache.commons.lang3.ArrayUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * If both are null, an IllegalArgumentException is thrown\n     * @since 2.1\n     * @throws IllegalArgumentException if both arguments are null\n     */",
        "id": "312",
        "project": "Lang",
        "bug_num": "35",
        "test_name": "org.apache.commons.lang3.ArrayUtils_ESTest::test352",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "// Undeclared exception!\n       \n        ArrayUtils.add((Integer[]) null, (-7), (Integer) null);"
    },
    {
        "focal_method": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n                hexDigits--;\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "test_prefix": "  public void test035()  throws Throwable  {\n      try { \n        NumberUtils.createNumber(\"--X+.\\\"LnzwmpM1g+fl\");\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // --X+.\\\"LnzwmpM1g+fl is not a valid number.\n         //\n         verifyException(\"org.apache.commons.lang3.math.NumberUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n     * prefix is more than 8.\n     * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */",
        "id": "313",
        "project": "Lang",
        "bug_num": "7",
        "test_name": "org.apache.commons.lang3.math.NumberUtils_ESTest::test035",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "NumberUtils.createNumber(\"--X+.\\\"LnzwmpM1g+fl\");"
    },
    {
        "focal_method": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n                hexDigits--;\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "test_prefix": "  public void test038()  throws Throwable  {\n      try { \n        NumberUtils.createNumber(\"--0X+\\\"L[nzw}mpMg+fl\");\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // --0X+\\\"L[nzw}mpMg+fl is not a valid number.\n         //\n         verifyException(\"org.apache.commons.lang3.math.NumberUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n     * prefix is more than 8.\n     * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */",
        "id": "314",
        "project": "Lang",
        "bug_num": "7",
        "test_name": "org.apache.commons.lang3.math.NumberUtils_ESTest::test038",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "NumberUtils.createNumber(\"--0X+\\\"L[nzw}mpMg+fl\");"
    },
    {
        "focal_method": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            int hexDigits = str.length() - 2; // drop 0x\n            if (str.startsWith(\"-\")) { // drop -\n                hexDigits--;\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "test_prefix": "  public void test047()  throws Throwable  {\n      try { \n        NumberUtils.createNumber(\"--0XVG\\\"AMz:>EyhF\");\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // --0XVG\\\"AMz:>EyhF is not a valid number.\n         //\n         verifyException(\"org.apache.commons.lang3.math.NumberUtils\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n     * prefix is more than 8.\n     * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */",
        "id": "315",
        "project": "Lang",
        "bug_num": "7",
        "test_name": "org.apache.commons.lang3.math.NumberUtils_ESTest::test047",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "NumberUtils.createNumber(\"--0XVG\\\"AMz:>EyhF\");"
    },
    {
        "focal_method": "    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }",
        "test_prefix": "  public void test30()  throws Throwable  {\n      String string0 = WordUtils.abbreviate(\"wTDdt<TJing. Mac\", 421, 13, \" \");\n      assertEquals(\"wTDdt<TJing. Mac\", string0);\n}",
        "docstring": "/**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */",
        "id": "316",
        "project": "Lang",
        "bug_num": "45",
        "test_name": "org.apache.commons.lang.WordUtils_ESTest::test30",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"wTDdt<TJing. Mac\", string0);",
        "prefix": "String string0 = WordUtils.abbreviate(\"wTDdt<TJing. Mac\", 421, 13, \" \");"
    },
    {
        "focal_method": "    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }",
        "test_prefix": "  public void test30()  throws Throwable  {\n      String string0 = WordUtils.abbreviate(\"wTDdt<TJing. Mac\", 421, 13, \" \");\n  }",
        "docstring": "/**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */",
        "id": "317",
        "project": "Lang",
        "bug_num": "45",
        "test_name": "org.apache.commons.lang.WordUtils_ESTest::test30",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"wTDdt<TJing. Mac\", string0);",
        "prefix": "String string0 = WordUtils.abbreviate(\"wTDdt<TJing. Mac\", 421, 13, \" \");"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test00()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.US;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\\\" ; gave up at index 83\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "318",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test00",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.US;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test01()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.ENGLISH;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"HZJV^H\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"HZJV^H\\\" ; gave up at index 2\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "319",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test01",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.ENGLISH;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"HZJV^H\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test02()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"WyGf<\\\"J\");\n      Locale locale0 = Locale.CHINESE;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"WyGf<\\\"J\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"WyGf<\\\"J\\\" ; gave up at index 3\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "320",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test02",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getTimeZone(\"WyGf<\\\"J\");\n      Locale locale0 = Locale.CHINESE;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"WyGf<\\\"J\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test17()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.FRANCE;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"`@Z$=yy`/|$~1LALU&P\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"`@Z$=yy`/|$~1LALU&P\\\" ; gave up at index 13\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "321",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test17",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.FRANCE;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"`@Z$=yy`/|$~1LALU&P\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"-\");\n      Locale locale0 = Locale.US;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"{K_EPT\\\"8Xh0!`)\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"{K_EPT\\\"8Xh0!`)\\\" ; gave up at index 4\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "322",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test18",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getTimeZone(\"-\");\n      Locale locale0 = Locale.US;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"{K_EPT\\\"8Xh0!`)\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test21()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"S(X\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"S(X\\\" ; gave up at index 2\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "323",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test21",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"S(X\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test22()  throws Throwable  {\n      Locale locale0 = Locale.ENGLISH;\n      TimeZone timeZone0 = TimeZone.getDefault();\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"D):ZG'] }\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"D):ZG'] }\\\" ; gave up at index 5\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "324",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test22",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "Locale locale0 = Locale.ENGLISH;\n      TimeZone timeZone0 = TimeZone.getDefault();\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"D):ZG'] }\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test23()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.CHINESE;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"W*f<\\\"T(HJH\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"W*f<\\\"T(HJH\\\" ; gave up at index 2\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "325",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test23",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.CHINESE;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"W*f<\\\"T(HJH\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test24()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.ENGLISH;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"y,}5Dn@;}[V\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"y,}5Dn@;}[V\\\" ; gave up at index 5\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "326",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test24",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.ENGLISH;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"y,}5Dn@;}[V\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test25()  throws Throwable  {\n      Locale locale0 = new Locale(\"Zt`q(\", \"Zt`q(\", \"Zt`q(\");\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"Zt`q(\");\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"-7|@]F5Tc%m($PLP~tw\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"-7|@]F5Tc%m($PLP~tw\\\" ; gave up at index 7\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "327",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test25",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "Locale locale0 = new Locale(\"Zt`q(\", \"Zt`q(\", \"Zt`q(\");\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"Zt`q(\");\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"-7|@]F5Tc%m($PLP~tw\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test27()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.GERMAN;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"/,q3rndcZ\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"/,q3rndcZ\\\" ; gave up at index 2\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "328",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test27",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.GERMAN;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"/,q3rndcZ\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test28()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"D0=of5C)x}=1AuB&\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"D0=of5C)x}=1AuB&\\\" ; gave up at index 3\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "329",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test28",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"D0=of5C)x}=1AuB&\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test29()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getTimeZone(\";J&%Dl.p[7Zh_nAhzE\");\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"FH2(bMqDjaKCbX\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"FH2(bMqDjaKCbX\\\" ; gave up at index 4\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "330",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test29",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getTimeZone(\";J&%Dl.p[7Zh_nAhzE\");\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"FH2(bMqDjaKCbX\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test30()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"3fr&HfA\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"3fr&HfA\\\" ; gave up at index 1\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "331",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test30",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"3fr&HfA\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test31()  throws Throwable  {\n      Locale locale0 = new Locale(\"6I\", \"6I\", \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"SNXk?8a4BQ_3A|Q+i\");\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"6I\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"6I\\\" ; gave up at index 1\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "332",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test31",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "Locale locale0 = new Locale(\"6I\", \"6I\", \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"SNXk?8a4BQ_3A|Q+i\");\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"6I\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test32()  throws Throwable  {\n      Locale locale0 = Locale.KOREAN;\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"].@?\");\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\")\\\"K9-z7 {jjN!\\\"+qVy\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\")\\\"K9-z7 {jjN!\\\"+qVy\\\" ; gave up at index 10\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "333",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test32",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "Locale locale0 = Locale.KOREAN;\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"].@?\");\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\")\\\"K9-z7 {jjN!\\\"+qVy\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test33()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.GERMAN;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"88vf,z'r\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"88vf,z'r\\\" ; gave up at index 2\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "334",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test33",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.GERMAN;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"88vf,z'r\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test34()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getTimeZone(\"9*f<\\\"H*H\");\n      Locale locale0 = Locale.US;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"9*f<\\\"H*H\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"9*f<\\\"H*H\\\" ; gave up at index 2\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "335",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test34",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getTimeZone(\"9*f<\\\"H*H\");\n      Locale locale0 = Locale.US;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"9*f<\\\"H*H\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test35()  throws Throwable  {\n      Locale locale0 = Locale.ENGLISH;\n      TimeZone timeZone0 = TimeZone.getDefault();\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\":3se'${myQQ9)!|\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\":3se'${myQQ9)!|\\\" ; gave up at index 3\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "336",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test35",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "Locale locale0 = Locale.ENGLISH;\n      TimeZone timeZone0 = TimeZone.getDefault();\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\":3se'${myQQ9)!|\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test36()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.JAPANESE;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"`@Z=yy`/|$~1LALU&P\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"`@Z=yy`/|$~1LALU&P\\\" ; gave up at index 12\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "337",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test36",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.JAPANESE;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"`@Z=yy`/|$~1LALU&P\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test37()  throws Throwable  {\n      Locale locale0 = Locale.ENGLISH;\n      TimeZone timeZone0 = TimeZone.getDefault();\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"]k>QHlD*\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"]k>QHlD*\\\" ; gave up at index 3\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "338",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test37",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "Locale locale0 = Locale.ENGLISH;\n      TimeZone timeZone0 = TimeZone.getDefault();\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"]k>QHlD*\", timeZone0, locale0);"
    },
    {
        "focal_method": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
        "test_prefix": "  public void test39()  throws Throwable  {\n      TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      try {\n        fastDateParser0 = new FastDateParser(\"@SKFxk)?Aeh4iJ\", timeZone0, locale0);\n        fail(\"Expecting exception: IllegalArgumentException\");\n      } catch(IllegalArgumentException e) {\n         //\n         // Failed to parse \\\"@SKFxk)?Aeh4iJ\\\" ; gave up at index 4\n         //\n         verifyException(\"org.apache.commons.lang3.time.FastDateParser\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */",
        "id": "339",
        "project": "Lang",
        "bug_num": "9",
        "test_name": "org.apache.commons.lang3.time.FastDateParser_ESTest::test39",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "TimeZone timeZone0 = TimeZone.getDefault();\n      Locale locale0 = Locale.KOREAN;\n      FastDateParser fastDateParser0 = null;\n      \n        fastDateParser0 = new FastDateParser(\"@SKFxk)?Aeh4iJ\", timeZone0, locale0);"
    },
    {
        "focal_method": "    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
        "test_prefix": "  public void test73()  throws Throwable  {\n      Object[] objectArray0 = new Object[3];\n      Object object0 = new Object();\n      objectArray0[0] = object0;\n      Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);\n      assertEquals(3, classArray0.length);\n}",
        "docstring": "/**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n     * If any of these objects is null, a null element will be inserted into the array.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */",
        "id": "340",
        "project": "Lang",
        "bug_num": "33",
        "test_name": "org.apache.commons.lang3.ClassUtils_ESTest::test73",
        "except_pred": "0",
        "assert_pred": "assertNotNull(classArray0);",
        "prefix": "Object[] objectArray0 = new Object[3];\n      Object object0 = new Object();\n      objectArray0[0] = object0;\n      Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);"
    },
    {
        "focal_method": "    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
        "test_prefix": "  public void test73()  throws Throwable  {\n      Object[] objectArray0 = new Object[3];\n      Object object0 = new Object();\n      objectArray0[0] = object0;\n      Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);\n  }",
        "docstring": "/**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.\n     * If any of these objects is null, a null element will be inserted into the array.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */",
        "id": "341",
        "project": "Lang",
        "bug_num": "33",
        "test_name": "org.apache.commons.lang3.ClassUtils_ESTest::test73",
        "except_pred": "0",
        "assert_pred": "assertNotNull(classArray0);",
        "prefix": "Object[] objectArray0 = new Object[3];\n      Object object0 = new Object();\n      objectArray0[0] = object0;\n      Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);"
    },
    {
        "focal_method": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "test_prefix": "  public void test030()  throws Throwable  {\n      Number number0 = NumberUtils.createNumber(\"6l\");\n      assertEquals(6L, number0);\n}",
        "docstring": "/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */",
        "id": "342",
        "project": "Lang",
        "bug_num": "58",
        "test_name": "org.apache.commons.lang.math.NumberUtils_ESTest::test030",
        "except_pred": "0",
        "assert_pred": "assertNotNull(number0);",
        "prefix": "Number number0 = NumberUtils.createNumber(\"6l\");"
    },
    {
        "focal_method": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "test_prefix": "  public void test030()  throws Throwable  {\n      Number number0 = NumberUtils.createNumber(\"6l\");\n  }",
        "docstring": "/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */",
        "id": "343",
        "project": "Lang",
        "bug_num": "58",
        "test_name": "org.apache.commons.lang.math.NumberUtils_ESTest::test030",
        "except_pred": "0",
        "assert_pred": "assertNotNull(number0);",
        "prefix": "Number number0 = NumberUtils.createNumber(\"6l\");"
    },
    {
        "focal_method": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "test_prefix": "  public void test017()  throws Throwable  {\n      try { \n        NumberUtils.createNumber(\"..\");\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // no message in exception (getMessage() returned null)\n         //\n         verifyException(\"java.math.BigDecimal\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */",
        "id": "344",
        "project": "Lang",
        "bug_num": "36",
        "test_name": "org.apache.commons.lang3.math.NumberUtils_ESTest::test017",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "NumberUtils.createNumber(\"..\");"
    },
    {
        "focal_method": "    public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      boolean boolean0 = LocaleUtils.isAvailableLocale((Locale) null);\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */",
        "id": "345",
        "project": "Lang",
        "bug_num": "57",
        "test_name": "org.apache.commons.lang.LocaleUtils_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "boolean boolean0 = LocaleUtils.isAvailableLocale((Locale) null);"
    },
    {
        "focal_method": "    public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n    }",
        "test_prefix": "  public void test18()  throws Throwable  {\n      boolean boolean0 = LocaleUtils.isAvailableLocale((Locale) null);\n  }",
        "docstring": "/**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */",
        "id": "346",
        "project": "Lang",
        "bug_num": "57",
        "test_name": "org.apache.commons.lang.LocaleUtils_ESTest::test18",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "boolean boolean0 = LocaleUtils.isAvailableLocale((Locale) null);"
    },
    {
        "focal_method": "    public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n    }",
        "test_prefix": "  public void test19()  throws Throwable  {\n      Locale locale0 = Locale.ENGLISH;\n      boolean boolean0 = LocaleUtils.isAvailableLocale(locale0);\n      assertTrue(boolean0);\n}",
        "docstring": "/**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */",
        "id": "347",
        "project": "Lang",
        "bug_num": "57",
        "test_name": "org.apache.commons.lang.LocaleUtils_ESTest::test19",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "Locale locale0 = Locale.ENGLISH;\n      boolean boolean0 = LocaleUtils.isAvailableLocale(locale0);"
    },
    {
        "focal_method": "    public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n    }",
        "test_prefix": "  public void test19()  throws Throwable  {\n      Locale locale0 = Locale.ENGLISH;\n      boolean boolean0 = LocaleUtils.isAvailableLocale(locale0);\n  }",
        "docstring": "/**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */",
        "id": "348",
        "project": "Lang",
        "bug_num": "57",
        "test_name": "org.apache.commons.lang.LocaleUtils_ESTest::test19",
        "except_pred": "0",
        "assert_pred": "assertEquals(true, boolean0);",
        "prefix": "Locale locale0 = Locale.ENGLISH;\n      boolean boolean0 = LocaleUtils.isAvailableLocale(locale0);"
    },
    {
        "focal_method": "    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len < 2) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 2) {\n                return new Locale(str);\n            }\n            if (len < 5) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n            final char ch4 = str.charAt(4);\n            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            }\n            if (len < 7) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(5) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      Locale locale0 = LocaleUtils.toLocale(\"_QJ\");\n      assertEquals(\"\", locale0.getVariant());\n}",
        "docstring": "/**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */",
        "id": "349",
        "project": "Lang",
        "bug_num": "5",
        "test_name": "org.apache.commons.lang3.LocaleUtils_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertNotNull(locale0);",
        "prefix": "Locale locale0 = LocaleUtils.toLocale(\"_QJ\");"
    },
    {
        "focal_method": "    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len < 2) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 2) {\n                return new Locale(str);\n            }\n            if (len < 5) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n            final char ch4 = str.charAt(4);\n            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            }\n            if (len < 7) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(5) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n    }",
        "test_prefix": "  public void test07()  throws Throwable  {\n      Locale locale0 = LocaleUtils.toLocale(\"_QJ\");\n  }",
        "docstring": "/**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */",
        "id": "350",
        "project": "Lang",
        "bug_num": "5",
        "test_name": "org.apache.commons.lang3.LocaleUtils_ESTest::test07",
        "except_pred": "0",
        "assert_pred": "assertNotNull(locale0);",
        "prefix": "Locale locale0 = LocaleUtils.toLocale(\"_QJ\");"
    },
    {
        "focal_method": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "test_prefix": "  public void test023()  throws Throwable  {\n      try { \n        NumberUtils.createNumber(\"0Xz46Pe\");\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // For input string: \\\"z46Pe\\\"\n         //\n         verifyException(\"java.lang.NumberFormatException\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */",
        "id": "351",
        "project": "Lang",
        "bug_num": "16",
        "test_name": "org.apache.commons.lang3.math.NumberUtils_ESTest::test023",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "NumberUtils.createNumber(\"0Xz46Pe\");"
    },
    {
        "focal_method": "    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                if (expPos > str.length()) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) { // NOPMD\n                            // Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
        "test_prefix": "  public void test024()  throws Throwable  {\n      try { \n        NumberUtils.createNumber(\"-0X\");\n        fail(\"Expecting exception: NumberFormatException\");\n      } catch(NumberFormatException e) {\n         //\n         // For input string: \\\"-\\\"\n         //\n         verifyException(\"java.lang.NumberFormatException\", e);\n      }\n  }",
        "docstring": "/**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */",
        "id": "352",
        "project": "Lang",
        "bug_num": "16",
        "test_name": "org.apache.commons.lang3.math.NumberUtils_ESTest::test024",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "NumberUtils.createNumber(\"-0X\");"
    },
    {
        "focal_method": "    public static String getShortClassName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }",
        "test_prefix": "  public void test11()  throws Throwable  {\n      String string0 = ClassUtils.getShortClassName(\"[LJNM-;\");\n      assertEquals(\"JNM-[]\", string0);\n}",
        "docstring": "/**\n     * <p>Gets the class name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the class name of the object without the package name, or the null value\n     */",
        "id": "353",
        "project": "Lang",
        "bug_num": "41",
        "test_name": "org.apache.commons.lang.ClassUtils_ESTest::test11",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"[LJNM-;\", string0);",
        "prefix": "String string0 = ClassUtils.getShortClassName(\"[LJNM-;\");"
    },
    {
        "focal_method": "    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }",
        "test_prefix": "  public void test12()  throws Throwable  {\n      String string0 = ClassUtils.getShortCanonicalName(\"[\");\n      assertEquals(\"][]\", string0);\n}",
        "docstring": "/**\n     * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     */",
        "id": "354",
        "project": "Lang",
        "bug_num": "41",
        "test_name": "org.apache.commons.lang.ClassUtils_ESTest::test12",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"[\", string0);",
        "prefix": "String string0 = ClassUtils.getShortCanonicalName(\"[\");"
    },
    {
        "focal_method": "    public static String getShortClassName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }",
        "test_prefix": "  public void test13()  throws Throwable  {\n      String string0 = ClassUtils.getShortClassName(\"[[LJNM-\");\n      assertEquals(\"LJNM-[][]\", string0);\n}",
        "docstring": "/**\n     * <p>Gets the class name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the class name of the object without the package name, or the null value\n     */",
        "id": "355",
        "project": "Lang",
        "bug_num": "41",
        "test_name": "org.apache.commons.lang.ClassUtils_ESTest::test13",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"[[LJNM-\", string0);",
        "prefix": "String string0 = ClassUtils.getShortClassName(\"[[LJNM-\");"
    },
    {
        "focal_method": "    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }",
        "test_prefix": "  public void test14()  throws Throwable  {\n      String string0 = ClassUtils.getShortCanonicalName(\"B\");\n      assertEquals(\"byte\", string0);\n}",
        "docstring": "/**\n     * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     */",
        "id": "356",
        "project": "Lang",
        "bug_num": "41",
        "test_name": "org.apache.commons.lang.ClassUtils_ESTest::test14",
        "except_pred": "0",
        "assert_pred": "assertEquals(\"b\", string0);",
        "prefix": "String string0 = ClassUtils.getShortCanonicalName(\"B\");"
    },
    {
        "focal_method": "    public static String getPackageName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }",
        "test_prefix": "  public void test21()  throws Throwable  {\n      // Undeclared exception!\n      try { \n        ClassUtils.getPackageName(\"[\");\n        fail(\"Expecting exception: StringIndexOutOfBoundsException\");\n      } catch(StringIndexOutOfBoundsException e) {\n      }\n  }",
        "docstring": "/**\n     * <p>Gets the package name of an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the package name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the package name of the object, or the null value\n     */",
        "id": "357",
        "project": "Lang",
        "bug_num": "41",
        "test_name": "org.apache.commons.lang.ClassUtils_ESTest::test21",
        "except_pred": "1",
        "assert_pred": "",
        "prefix": "// Undeclared exception!\n       \n        ClassUtils.getPackageName(\"[\");"
    },
    {
        "focal_method": "    public ExtendedMessageFormat(String pattern) {\n        this(pattern, Locale.getDefault());\n    }",
        "test_prefix": "  public void test08()  throws Throwable  {\n      ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(\"*3-\");\n      HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();\n      ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(\"*3-\", hashMap0);\n      boolean boolean0 = extendedMessageFormat0.equals(extendedMessageFormat1);\n      assertFalse(boolean0);\n}",
        "docstring": "/**\n     * Create a new ExtendedMessageFormat for the default locale.\n     * \n     * @param pattern  the pattern to use, not null\n     * @throws IllegalArgumentException in case of a bad pattern.\n     */",
        "id": "358",
        "project": "Lang",
        "bug_num": "23",
        "test_name": "org.apache.commons.lang3.text.ExtendedMessageFormat_ESTest::test08",
        "except_pred": "0",
        "assert_pred": "assertEquals(false, boolean0);",
        "prefix": "ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(\"*3-\");\n      HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();\n      ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(\"*3-\", hashMap0);\n      boolean boolean0 = extendedMessageFormat0.equals(extendedMessageFormat1);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      char[] charArray0 = new char[7];\n      charArray0[3] = '&';\n      charArray0[4] = '#';\n      charArray0[5] = 'X';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n      assertEquals(\"\\u0000\\u0000\\u0000&#X\\u0000\", string0);\n}",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "359",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[7];\n      charArray0[3] = '&';\n      charArray0[4] = '#';\n      charArray0[5] = 'X';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test2()  throws Throwable  {\n      char[] charArray0 = new char[7];\n      charArray0[3] = '&';\n      charArray0[4] = '#';\n      charArray0[5] = 'X';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n  }",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "360",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test2",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[7];\n      charArray0[3] = '&';\n      charArray0[4] = '#';\n      charArray0[5] = 'X';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test3()  throws Throwable  {\n      char[] charArray0 = new char[6];\n      charArray0[3] = '&';\n      charArray0[4] = '#';\n      charArray0[5] = 'X';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n      assertEquals(\"\\u0000\\u0000\\u0000&#X\", string0);\n}",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "361",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test3",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[6];\n      charArray0[3] = '&';\n      charArray0[4] = '#';\n      charArray0[5] = 'X';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test3()  throws Throwable  {\n      char[] charArray0 = new char[6];\n      charArray0[3] = '&';\n      charArray0[4] = '#';\n      charArray0[5] = 'X';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n  }",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "362",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test3",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[6];\n      charArray0[3] = '&';\n      charArray0[4] = '#';\n      charArray0[5] = 'X';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      char[] charArray0 = new char[3];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'b';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n      assertEquals(\"&#b\", string0);\n}",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "363",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[3];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'b';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test4()  throws Throwable  {\n      char[] charArray0 = new char[3];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'b';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n  }",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "364",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test4",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[3];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'b';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test5()  throws Throwable  {\n      char[] charArray0 = new char[6];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = '4';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n      assertEquals(\"\\u0004\\u0000\\u0000\\u0000\", string0);\n}",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "365",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test5",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[6];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = '4';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test5()  throws Throwable  {\n      char[] charArray0 = new char[6];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = '4';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n  }",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "366",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test5",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[6];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = '4';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test6()  throws Throwable  {\n      char[] charArray0 = new char[5];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'l';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n      assertEquals(\"&#l\\u0000\\u0000\", string0);\n}",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "367",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test6",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[5];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'l';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test6()  throws Throwable  {\n      char[] charArray0 = new char[5];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'l';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n  }",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "368",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test6",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[5];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'l';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test7()  throws Throwable  {\n      char[] charArray0 = new char[6];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'B';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n      assertEquals(\"&#B\\u0000\\u0000\\u0000\", string0);\n}",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "369",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test7",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[6];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'B';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test7()  throws Throwable  {\n      char[] charArray0 = new char[6];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'B';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n  }",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "370",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test7",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[6];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = 'B';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test8()  throws Throwable  {\n      char[] charArray0 = new char[3];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = '4';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n      assertEquals(\"\\u0004\", string0);\n}",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "371",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test8",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[3];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = '4';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
        "test_prefix": "  public void test8()  throws Throwable  {\n      char[] charArray0 = new char[3];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = '4';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);\n  }",
        "docstring": "/**\n     * {@inheritDoc}\n     */",
        "id": "372",
        "project": "Lang",
        "bug_num": "19",
        "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper_ESTest::test8",
        "except_pred": "0",
        "assert_pred": "assertEquals(2, charBuffer0.length());",
        "prefix": "char[] charArray0 = new char[3];\n      charArray0[0] = '&';\n      charArray0[1] = '#';\n      charArray0[2] = '4';\n      CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);\n      NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();\n      String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);"
    },
    {
        "focal_method": "    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, false);\n        return gval.getTime();\n    }",
        "test_prefix": "  public void test53()  throws Throwable  {\n      ZoneInfo zoneInfo0 = (ZoneInfo)DateUtils.UTC_TIME_ZONE;\n      Locale locale0 = Locale.CANADA;\n      Calendar calendar0 = MockCalendar.getInstance((TimeZone) zoneInfo0, locale0);\n      Calendar calendar1 = DateUtils.truncate(calendar0, 13);\n      assertEquals(\"org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\\\"GMT\\\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]\", calendar1.toString());\n}",
        "docstring": "/**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */",
        "id": "373",
        "project": "Lang",
        "bug_num": "65",
        "test_name": "org.apache.commons.lang.time.DateUtils_ESTest::test53",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "ZoneInfo zoneInfo0 = (ZoneInfo)DateUtils.UTC_TIME_ZONE;\n      Locale locale0 = Locale.CANADA;\n      Calendar calendar0 = MockCalendar.getInstance((TimeZone) zoneInfo0, locale0);\n      Calendar calendar1 = DateUtils.truncate(calendar0, 13);"
    },
    {
        "focal_method": "    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, true);\n        return gval.getTime();\n    }",
        "test_prefix": "  public void test54()  throws Throwable  {\n      ZoneInfo zoneInfo0 = (ZoneInfo)DateUtils.UTC_TIME_ZONE;\n      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(zoneInfo0);\n      Date date0 = DateUtils.round((Object) mockGregorianCalendar0, 12);\n      assertEquals(\"Fri Feb 14 20:21:00 GMT 2014\", date0.toString());\n}",
        "docstring": "/**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */",
        "id": "374",
        "project": "Lang",
        "bug_num": "65",
        "test_name": "org.apache.commons.lang.time.DateUtils_ESTest::test54",
        "except_pred": "0",
        "assert_pred": "",
        "prefix": "ZoneInfo zoneInfo0 = (ZoneInfo)DateUtils.UTC_TIME_ZONE;\n      MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(zoneInfo0);\n      Date date0 = DateUtils.round((Object) mockGregorianCalendar0, 12);"
    }
]